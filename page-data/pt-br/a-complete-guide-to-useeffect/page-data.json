{"componentChunkName":"component---src-templates-blog-post-js","path":"/pt-br/a-complete-guide-to-useeffect/","result":{"data":{"site":{"siteMetadata":{"title":"The Papers not read","author":"The Chuong Chu"}},"markdownRemark":{"id":"d912c3fa-1743-5046-b337-d5f25063e454","html":"<p>Voc√™ escreveu alguns componentes com <a href=\"https://reactjs.org/docs/hooks-intro.html\">Hooks</a>. Talvez at√© um pequeno app. At√© ent√£o voc√™ est√° satisfeito. Est√° confort√°vel com a API e aprendeu alguns truques durante o caminho. Voc√™ at√© <a href=\"https://reactjs.org/docs/hooks-custom.html\">criou alguns Hooks personalizados</a> para extrair l√≥gica repetitiva (l√° se foram 300 linhas!) e mostrou tudo isso para seus colegas. \"√ìtimo trabalho!\", eles disseram.</p>\n<p>Mas, algumas vezes, quando voc√™ usa <code>useEffect</code>, os peda√ßos n√£o se encaixam muito bem. Voc√™ tem aquela sensa√ß√£o inc√¥moda de que est√° perdendo alguma coisa. Parece semelhante aos ciclos de vida das classes...mas √© mesmo? Voc√™ se encontra fazendo perguntas como:</p>\n<ul>\n<li>ü§î Como fa√ßo para replicar <code>componentDidMount</code> com <code>useEffect</code>?</li>\n<li>ü§î Como fa√ßo para buscar dados corretamente dentro de <code>useEffect</code>? O que √© <code>[]</code>?</li>\n<li>ü§î Preciso especificar fun√ß√µes como depend√™ncias do efeito ou n√£o?</li>\n<li>ü§î Por que √†s vezes recebo um loop infinito na busca de dados?</li>\n<li>ü§î Por que √†s vezes recebo um <em>state</em> ou <em>props</em> antiga dentro do meu efeito?</li>\n</ul>\n<p>Quando comecei a usar o Hooks, tamb√©m fiquei confuso com todas essas perguntas. Mesmo ao escrever os documentos iniciais, eu n√£o tinha uma compreens√£o firme de algumas das sutilezas. Desde ent√£o, tive alguns momentos \"aha\" que quero compartilhar com voc√™. <strong>Faremos um mergulho profundo nesses detalhes, trazendo a superf√≠cie as respostas a essas perguntas, que no final, parecer√£o √≥bvias para voc√™.</strong></p>\n<p>Para <strong>ver</strong> essas respostas, precisamos dar um passo para tr√°s. O objetivo deste artigo n√£o √© fornecer uma lista de receitas. √â para ajudar voc√™ a realmente \"clicar\" o <code>useEffect</code>. N√£o haver√° muito a aprender. Na verdade, passaremos a maior parte do tempo <em>desaprendendo</em>.</p>\n<p><strong>S√≥ depois que parei de olhar para o Hook <code>useEffect</code> atrav√©s do prisma que estou acostumado dos m√©todos de ciclo de vida de classes, que todas as pe√ßas se juntaram para mim.</strong></p>\n<blockquote>\n<p>‚ÄúDesaprenda o que voc√™ aprendeu.‚Äù ‚Äî Yoda</p>\n</blockquote>\n<p><img src=\"./yoda.jpg\" alt=\"Yoda cheirando o ar. Legenda: ‚ÄúSinto cheiro de bacon.‚Äù\"></p>\n<hr>\n<p><strong>Este artigo assume que voc√™ esteja familiarizado com a API do <a href=\"https://reactjs.org/docs/hooks-effect.html\"><code>useEffect</code></a>.</strong></p>\n<p><strong>Tamb√©m √© <em>muito</em> longo. √â como um mini-livro. Esse √© apenas o meu formato preferido. Mas eu escrevi um TLDR logo abaixo se voc√™ est√° com pressa ou n√£o se importa.</strong></p>\n<p><strong>Se voc√™ n√£o se sentir confort√°vel com guias que mergulham profundo nos detalhes, espere at√© que essas explica√ß√µes apare√ßam em outro lugar. Assim como quando o React saiu em 2013, levar√° algum tempo para que as pessoas reconhe√ßam um modelo mental diferente e o ensinem.</strong></p>\n<hr>\n<h2>TLDR</h2>\n<p>Aqui est√° um r√°pido TLDR se voc√™ n√£o quiser ler a coisa toda. Se algumas partes n√£o fizerem sentido, voc√™ pode rolar para baixo at√© encontrar algo relacionado.</p>\n<p>Sinta-se livre para ignor√°-lo se voc√™ pretende ler o post inteiro. Tamb√©m vou vincul√°-lo no final.</p>\n<p><strong>ü§î Pergunta: Como fa√ßo para replicar <code>componentDidMount</code> com <code>useEffect</code>?</strong></p>\n<p>Embora voc√™ possa usar o <code>useEffect(fn, [])</code>, n√£o √© um equivalente exato. Ao contr√°rio do <code>componentDidMount</code>, ele ir√° capturar <em>props</em> e <em>state</em>. Assim, mesmo dentro dos retornos de chamada, voc√™ ver√° os valores iniciais de <em>props</em> e <em>state</em>. Se voc√™ quiser ver algo \"mais recente\", voc√™ pode escrever uma <em>ref</em> para isso. Mas normalmente h√° uma maneira mais simples de estruturar o c√≥digo para que voc√™ n√£o precise fazer isso. Tenha em mente que o modelo mental para efeitos √© diferente de <code>componentDidMount</code> e outros ciclos de vida, e tentar encontrar seus equivalentes exatos pode te confundir mais do que ajudar. Para se tornar produtivo, voc√™ precisa \"pensar em efeitos\", e o modelo mental deles est√° mais perto de \"implementar a sincroniza√ß√£o\" do que \"responder a eventos do ciclo de vida\".</p>\n<p><strong>ü§î Pergunta: Como fa√ßo para buscar dados corretamente dentro de <code>useEffect</code>? O que √© <code>[]</code>?</strong></p>\n<p><a href=\"https://www.robinwieruch.de/react-hooks-fetch-data/\">Este artigo</a> √© um bom manual sobre como buscar dados com <code>useEffect</code>. Certifique-se de ler at√© o fim! N√£o √© t√£o longo como este. <code>[]</code> significa que o efeito n√£o usa nenhum valor que participa do fluxo de dados do React e, por esse motivo, √© seguro para ser aplicado apenas uma vez. Tamb√©m √© uma fonte comum de erros quando o valor √© realmente usado. Voc√™ precisar√° aprender algumas estrat√©gias (principalmente <code>useReducer</code> e <code>useCallback</code>) que podem remover a necessidade de uma depend√™ncia, ao inv√©s de omitir isso incorretamente.</p>\n<p><strong>ü§î Pergunta: Preciso especificar fun√ß√µes como depend√™ncias do efeito ou n√£o?</strong></p>\n<p>A recomenda√ß√£o √© mover fun√ß√µes que n√£o precisam de <em>props</em> ou <em>state</em> para fora do seu componente e extrair aquelas que s√£o usadas apenas por um efeito, para dentro desse efeito. Se mesmo depois disso, o efeito ainda acabar usando fun√ß√µes do escopo da renderiza√ß√£o (incluindo fun√ß√µes vindas de <em>props</em>), envolva-as em <code>useCallback</code> aonde elas estiverem definidas e repita o processo. Por que isso √© importante? Fun√ß√µes podem \"ver\" valores de <em>props</em> e <em>state</em>, significa eles participam do fluxo de dados do React.</p>\n<p><strong>ü§î Pergunta: Por que √†s vezes recebo um loop infinito na busca de dados?</strong></p>\n<p>Isso pode acontecer se voc√™ estiver buscando dados em um efeito sem o segundo argumento de depend√™ncias. Sem ele, os efeitos s√£o executados ap√≥s cada renderiza√ß√£o - e definindo um novo estado acionar√° os efeitos novamente. Um loop infinito tamb√©m pode acontecer se voc√™ especificar um valor que sempre muda no array de depend√™ncias. Voc√™ pode descobrir qual deles, removendo-os um por um. No entanto, remover uma depend√™ncia usada (ou especificar cegamente <code>[]</code>) geralmente √© uma corre√ß√£o incorreta. Ao inv√©s disso, corrija o problema na sua origem. Por exemplo, fun√ß√µes podem causar esse problema e coloc√°-las dentro de efeitos, movendo-as ou envolvendo-as com o uso de <code>useCallback</code>. Para evitar a recria√ß√£o de objetos, o <code>useMemo</code> pode servir a um prop√≥sito semelhante.</p>\n<p><strong>ü§î Pergunta: Por que √†s vezes recebo um <em>state</em> ou <em>props</em> antiga dentro do meu efeito?</strong></p>\n<p>Os efeitos sempre podem \"ver\" as <em>props</em> e <em>state</em> da renderiza√ß√£o em que foram definidos. <a href=\"https://overreacted.io/how-are-function-components-different-from-classes/\">Isso ajuda a evitar erros</a>, mas em alguns casos pode ser irritante. Para esses casos, voc√™ pode manter, explicitamente, algum valor em uma <em>ref</em> mut√°vel (o artigo do link explica isso no final). Se voc√™ acha que est√° vendo <em>props</em> ou <em>state</em> a de uma renderiza√ß√£o antiga, mas n√£o √© o que voc√™ espera, voc√™ provavelmente deixou passar alguma depend√™ncia. Tente usar a <a href=\"https://github.com/facebook/react/issues/14920\">regra do linter</a> para te treinar a exerg√°-los. Depois de alguns dias, ser√° como uma segunda natureza para voc√™. Veja tamb√©m <a href=\"https://reactjs.org/docs/hooks-faq.html#why-am-i-seeing-stale-props-or-state-inside-my-function\">essa reposta</a> no nosso FAQ.</p>\n<hr>\n<p>Espero que este TLDR tenha sido √∫til! Caso contr√°rio, vamos continuar.</p>\n<hr>\n<h2>Cada renderiza√ß√£o tem seus pr√≥prios <em>props</em> e <em>state</em></h2>\n<p>Antes de falarmos sobre efeitos, precisamos falar sobre renderiza√ß√£o.</p>\n<p>Aqui est√° um contador. Olhe a linha destacada de perto:</p>\n<pre><code class=\"language-jsx{6}\">function Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    &#x3C;div>\n      &#x3C;p>You clicked {count} times&#x3C;/p>\n      &#x3C;button onClick={() => setCount(count + 1)}>\n        Click me\n      &#x3C;/button>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>O que isso significa? Ser√° que <code>count</code>, de alguma forma, \"fica olhando\" as altera√ß√µes ao nosso estado e atualiza automaticamente? Essa pode ser uma primeira intui√ß√£o quando voc√™ aprende React, mas n√£o √© um <a href=\"https://overreacted.io/react-as-a-ui-runtime/\">modelo mental preciso</a>.</p>\n<p>Neste exemplo, <code>count</code> √© apenas um n√∫mero. N√£o √© uma m√°gica de \"liga√ß√£o de dados\" (<strong>data binding</strong>), um \"observador\" (<strong>watcher</strong>), um \"proxy\" ou qualquer outra coisa. √â um bom e antigo n√∫mero como este:</p>\n<pre><code class=\"language-jsx\">const count = 42;\n// ...\n&#x3C;p>You clicked {count} times&#x3C;/p>\n// ...\n</code></pre>\n<p>A primeira vez que nosso componente renderiza, a vari√°vel <code>count</code> que obtemos de <code>useState()</code> √© <code>0</code>. Quando chamamos <code>setCount(1)</code>, o React chama nosso componente novamente. Desta vez, a contagem ser√° <code>1</code>. E assim por diante:</p>\n<pre><code class=\"language-jsx{3,11,19}\">// Durante primeira renderiza√ß√£o\nfunction Counter() {\n  const count = 0; // Returned by useState()\n  // ...\n  &#x3C;p>You clicked {count} times&#x3C;/p>\n  // ...\n}\n\n// Ap√≥s um clique, nossa fun√ß√£o √© chamada novamente\nfunction Counter() {\n  const count = 1; // Returned by useState()\n  // ...\n  &#x3C;p>You clicked {count} times&#x3C;/p>\n  // ...\n}\n\n// Ap√≥s outro clique, nossa fun√ß√£o √© chamada novamente\nfunction Counter() {\n  const count = 2; // Returned by useState()\n  // ...\n  &#x3C;p>You clicked {count} times&#x3C;/p>\n  // ...\n}\n</code></pre>\n<p><strong>Sempre que atualizamos o estado, o React chama nosso componente. Cada renderiza√ß√£o \"v√™\" seu pr√≥prio valor de <code>count</code>, que √© uma <em>constante</em> dentro de nossa fun√ß√£o.</strong></p>\n<p>Portanto, essa linha n√£o faz nenhuma liga√ß√£o de dados especial:</p>\n<pre><code class=\"language-jsx\">&#x3C;p>You clicked {count} times&#x3C;/p>\n</code></pre>\n<p><strong>Ela apenas incorpora um valor num√©rico na sa√≠da de renderiza√ß√£o.</strong> Esse n√∫mero √© fornecido pelo React. Quando chamamos <code>setCount</code>, React chama nosso componente novamente com um valor de contagem diferente. Em seguida, o React atualiza o DOM para corresponder √† nossa nova sa√≠da de renderiza√ß√£o.</p>\n<p>A principal conclus√£o √© que a constante <code>count</code>, em qualquer renderiza√ß√£o, n√£o muda com o tempo. √â nosso componente que √© chamado novamente e cada renderiza√ß√£o \"v√™\" seu pr√≥prio valor de contagem isolado entre renderiza√ß√µes.</p>\n<p><em>(Para uma vis√£o detalhada desse processo, confira meu post <a href=\"https://overreacted.io/react-as-a-ui-runtime/\">React as a UI Runtime</a>.)</em></p>\n<h2>Cada renderiza√ß√£o tem seus pr√≥prios manipuladores de eventos</h2>\n<p>Por enquanto, tudo bem. E quanto aos manipuladores de eventos?</p>\n<p>Veja este exemplo. Ele mostra um alerta com <code>count</code> ap√≥s tr√™s segundos:</p>\n<pre><code class=\"language-jsx{4-8,16-18}\">function Counter() {\n  const [count, setCount] = useState(0);\n\n  function handleAlertClick() {\n    setTimeout(() => {\n      alert('You clicked on: ' + count);\n    }, 3000);\n  }\n\n  return (\n    &#x3C;div>\n      &#x3C;p>You clicked {count} times&#x3C;/p>\n      &#x3C;button onClick={() => setCount(count + 1)}>\n        Click me\n      &#x3C;/button>\n      &#x3C;button onClick={handleAlertClick}>\n        Show alert\n      &#x3C;/button>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>Digamos que eu fa√ßa a seguinte sequ√™ncia de etapas:</p>\n<ul>\n<li><strong>Incrementar</strong> o contador 3 vezes</li>\n<li><strong>Pressionar</strong> \"Mostrar alerta\"</li>\n<li><strong>Incrementar</strong> o contador para 5 antes que o tempo limite seja disparado</li>\n</ul>\n<p><img src=\"./counter.gif\" alt=\"Demonstra√ß√£o do Counter\"></p>\n<p>O que voc√™ espera que o alerta mostre? Voc√™ espera que seja 5 - que √© o estado do contador no momento do alerta? Ou que ir√° mostrar 3 - o estado quando eu cliquei?</p>\n<hr>\n<p><em>spoilers √† frente</em></p>\n<hr>\n<p>V√° em frente e <a href=\"https://codesandbox.io/s/w2wxl3yo0l\">tente voc√™ mesmo!</a></p>\n<p>Se o comportamento n√£o fizer muito sentido para voc√™, imagine um exemplo mais pr√°tico: um aplicativo de bate-papo com o ID do destinat√°rio atual no estado e um bot√£o Enviar. <a href=\"https://overreacted.io/how-are-function-components-different-from-classes/\">Este artigo</a> explora as raz√µes em profundidade, mas a resposta correta √© 3.</p>\n<p>O alerta ir√° \"capturar\" o estado no momento em que eu cliquei no bot√£o.</p>\n<p><em>(Tamb√©m existem maneiras de implementar o outro comportamento, mas vou me concentrar no caso padr√£o por enquanto. Ao construir um modelo mental, √© importante distinguir o \"caminho de menor resist√™ncia\" das sa√≠das de emerg√™ncia que voc√™ pode utilizar uma vez ou outra.)</em></p>\n<hr>\n<p>Mas como isso funciona?</p>\n<p>N√≥s vimos que o valor <code>count</code> √© uma constante para cada chamada espec√≠fica da nossa fun√ß√£o. Vale a pena enfatizar isso - <strong>nossa fun√ß√£o √© chamada muitas vezes (uma vez para cada renderiza√ß√£o), mas em cada uma dessas vezes o valor de <code>count</code> dentro dela √© constante e configurado para um valor espec√≠fico (o estado para aquela renderiza√ß√£o).</strong></p>\n<p>Isso n√£o √© espec√≠fico do React - o comportamento regular de fun√ß√µes funcionam de maneira semelhante:</p>\n<pre><code class=\"language-jsx{2}\">function sayHi(person) {\n  const name = person.name;\n  setTimeout(() => {\n    alert('Hello, ' + name);\n  }, 3000);\n}\n\nlet someone = {name: 'Dan'};\nsayHi(someone);\n\nsomeone = {name: 'Yuzhi'};\nsayHi(someone);\n\nsomeone = {name: 'Dominic'};\nsayHi(someone);\n</code></pre>\n<p>Nesse <a href=\"https://codesandbox.io/s/mm6ww11lk8\">exemplo</a>, a vari√°vel externa <code>someone</code> √© reatribu√≠da v√°rias vezes. (Assim como em algum lugar no React, o estado <em>atual</em> do component pode mudar.) <strong>No entanto, no interior de <code>sayHi</code>, h√° uma constante local chamada <code>name</code> associada a uma <code>person</code> de uma chamada espec√≠fica.</strong> Essa constante √© local, por isso √© isolado entre as chamadas! Como resultado, quando os temporizadores s√£o acionados, cada alerta \"lembra\" o pr√≥prio <code>name</code>.</p>\n<p>Isso explica como o manipulador de eventos captura <code>count</code> no momento do clique. Se aplicarmos o mesmo princ√≠pio de substitui√ß√£o, cada render \"v√™\" o seu pr√≥prio <code>count</code>:</p>\n<pre><code class=\"language-jsx{3,15,27}\">// Durante primeira renderiza√ß√£o\nfunction Counter() {\n  const count = 0; // Returned by useState()\n  // ...\n  function handleAlertClick() {\n    setTimeout(() => {\n      alert('You clicked on: ' + count);\n    }, 3000);\n  }\n  // ...\n}\n\n// Ap√≥s um clique, nossa fun√ß√£o √© chamada novamente\nfunction Counter() {\n  const count = 1; // Returned by useState()\n  // ...\n  function handleAlertClick() {\n    setTimeout(() => {\n      alert('You clicked on: ' + count);\n    }, 3000);\n  }\n  // ...\n}\n\n// Ap√≥s outro clique, nossa fun√ß√£o √© chamada novamente\nfunction Counter() {\n  const count = 2; // Returned by useState()\n  // ...\n  function handleAlertClick() {\n    setTimeout(() => {\n      alert('You clicked on: ' + count);\n    }, 3000);\n  }\n  // ...\n}\n</code></pre>\n<p>Ent√£o, efetivamente, cada render retorna sua pr√≥pria \"vers√£o\" de <code>handleAlertClick</code>. Cada uma dessas vers√µes \"lembra\" o seu pr√≥prio valor de <code>count</code>:</p>\n<pre><code class=\"language-jsx{6,10,19,23,32,36}\">// Durante primeira renderiza√ß√£o\nfunction Counter() {\n  // ...\n  function handleAlertClick() {\n    setTimeout(() => {\n      alert('You clicked on: ' + 0);\n    }, 3000);\n  }\n  // ...\n  &#x3C;button onClick={handleAlertClick} /> // Com 0 dentro\n  // ...\n}\n\n// Ap√≥s um clique, nossa fun√ß√£o √© chamada novamente\nfunction Counter() {\n  // ...\n  function handleAlertClick() {\n    setTimeout(() => {\n      alert('You clicked on: ' + 1);\n    }, 3000);\n  }\n  // ...\n  &#x3C;button onClick={handleAlertClick} /> // Com 1 dentro\n  // ...\n}\n\n// Ap√≥s outro clique, nossa fun√ß√£o √© chamada novamente\nfunction Counter() {\n  // ...\n  function handleAlertClick() {\n    setTimeout(() => {\n      alert('You clicked on: ' + 2);\n    }, 3000);\n  }\n  // ...\n  &#x3C;button onClick={handleAlertClick} /> // Com 2 dentro\n  // ...\n}\n</code></pre>\n<p>√â por isso que <a href=\"https://codesandbox.io/s/w2wxl3yo0l\">nesse exemplo</a>, os manipuladores de eventos \"pertencem\" a uma determinada renderiza√ß√£o e quando voc√™ clica, ele mant√©m com o estado de <code>counter</code> daquela renderiza√ß√£o.</p>\n<p><strong>Dentro de qualquer renderiza√ß√£o em particular, os objetos e o estado permanecem para sempre iguais.</strong> Mas se <em>props</em> e <em>state</em> forem isolados entre renderizadores, o mesmo acontecer√° com qualquer valor usando-os (incluindo os manipuladores de eventos). Eles tamb√©m \"pertencem\" a uma renderiza√ß√£o espec√≠fica. Assim, mesmo as fun√ß√µes ass√≠ncronas dentro de um manipulador de eventos \"ir√£o ver\" o mesmo valor de <code>count</code>.</p>\n<p><em>Nota: eu adicionei valores literais do <code>count</code> diretamente nas fun√ß√µes <code>handleAlertClick</code> acima. Essa substitui√ß√£o mental √© segura pois <code>count</code> n√£o pode ser alterado em uma renderiza√ß√£o espec√≠fica. √â declarado como uma <code>const</code> e √© um n√∫mero. Seria seguro pensar da mesma maneira sobre outros valores, como objetos, mas somente se concordarmos em evitar muta√ß√£o no estado. Chamar <code>setSomething(newObj)</code> com um novo objeto rec√©m-criado, ao inv√©s de mut√°-lo, √© bom pois o estado pertencente a renderiza√ß√µes anteriores ficar√° intacto.</em></p>\n<h2>Cada renderiza√ß√£o tem seus pr√≥prios efeitos</h2>\n<p>Este deveria ser um post sobre efeitos, mas ainda n√£o falamos sobre eles ainda! N√≥s vamos corrigir isso agora. Acontece que os efeitos n√£o s√£o realmente diferentes.</p>\n<p>Vamos voltar a um <a href=\"https://reactjs.org/docs/hooks-effect.html\">exemplo da documenta√ß√£o</a>:</p>\n<pre><code class=\"language-jsx{4-6}\">function Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    document.title = `You clicked ${count} times`;\n  });\n\n  return (\n    &#x3C;div>\n      &#x3C;p>You clicked {count} times&#x3C;/p>\n      &#x3C;button onClick={() => setCount(count + 1)}>\n        Click me\n      &#x3C;/button>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p><strong>Aqui est√° uma pergunta para voc√™: como fazer para que o efeito leia o estado mais recente de <code>count</code>?</strong></p>\n<p>Talvez haja algum tipo de \"vincula√ß√£o de dados\" ou \"observa√ß√£o\" que fa√ßa a atualiza√ß√£o cont√≠nua de <code>count</code> dentro da fun√ß√£o de efeito? Talvez <code>count</code> seja uma vari√°vel mut√°vel que o React define dentro de nosso componente para que nosso efeito sempre tenha o valor mais recente?</p>\n<p>N√£o.</p>\n<p>N√≥s j√° sabemos que <code>count</code> √© constante dentro de uma determinada renderiza√ß√£o. Os manipuladores de eventos \"veem\" o estado de <code>count</code> da renderiza√ß√£o que eles \"pertencem\" pois <code>count</code> √© uma vari√°vel dentro do seu escopo. O mesmo √© verdade para efeitos!</p>\n<p><strong>N√£o √© a vari√°vel <code>count</code> que de alguma forma mudou dentro de um efeito \"imut√°vel\". √â a <em>fun√ß√£o do efeito em si</em> que √© diferente em cada renderiza√ß√£o.</strong></p>\n<p>Cada vers√£o \"v√™\" o valor de <code>count</code> da renderiza√ß√£o que ela \"pertence\":</p>\n<pre><code class=\"language-jsx{5-8,17-20,29-32}\">// Durante primeira renderiza√ß√£o\nfunction Counter() {\n  // ...\n  useEffect(\n    // Fun√ß√£o de efeito da primeira renderiza√ß√£o\n    () => {\n      document.title = `You clicked ${0} times`;\n    }\n  );\n  // ...\n}\n\n// Ap√≥s um clique, nossa fun√ß√£o √© chamada novamente\nfunction Counter() {\n  // ...\n  useEffect(\n    // Fun√ß√£o de efeito da segunda renderiza√ß√£o\n    () => {\n      document.title = `You clicked ${1} times`;\n    }\n  );\n  // ...\n}\n\n// Ap√≥s outro clique, nossa fun√ß√£o √© chamada novamente\nfunction Counter() {\n  // ...\n  useEffect(\n    // Fun√ß√£o de efeito da terceira renderiza√ß√£o\n    () => {\n      document.title = `You clicked ${2} times`;\n    }\n  );\n  // ..\n}\n</code></pre>\n<p>O React lembra a fun√ß√£o de efeito que voc√™ forneceu e a executa depois de liberar as altera√ß√µes para o DOM e permitir que o navegador pinte a tela.</p>\n<p>Mesmo se falarmos de um conceitual √∫nico <em>efeito</em> aqui (atualizando o t√≠tulo do documento), ele √© representado por uma <em>fun√ß√£o diferente</em> em cada renderiza√ß√£o - e cada fun√ß√£o de efeito \"v√™\" suas <em>props</em> e <em>state</em> da renderiza√ß√£o espec√≠fica √† qual ele \"pertence\".</p>\n<p><strong>Conceitualmente, voc√™ pode imaginar que os efeitos <em>fazem parte do resultado da renderiza√ß√£o</em>.</strong></p>\n<p>Falando rigorosamente, eles n√£o s√£o (tudo isso para <a href=\"https://overreacted.io/why-do-hooks-rely-on-call-order/\">permitir a composi√ß√£o do Hook</a> sem uma sintaxe grotesca ou com alguma sobrecarga em tempo de execu√ß√£o). No modelo mental que estamos construindo, as fun√ß√µes de efeito pertencem a uma renderiza√ß√£o espec√≠fica, da mesma maneira que os manipuladores de eventos.</p>\n<hr>\n<p>Para ter certeza de que temos uma s√≥lida compreens√£o, vamos recapitular nossa primeira renderiza√ß√£o:</p>\n<ul>\n<li><strong>React</strong>: Me retorna a interface do usu√°rio quando o estado √© <code>0</code>.</li>\n<li>\n<p><strong>Seu Componente</strong>:</p>\n<ul>\n<li>Aqui est√° o resultado da renderiza√ß√£o: <code>&#x3C;p>You clicked 0 times&#x3C;/p></code>.</li>\n<li>Lembre-se de executar este efeito depois que voc√™ estiver pronto: <code>() => { document.title = 'You clicked 0 times' }</code>.</li>\n</ul>\n</li>\n<li><strong>React</strong>: Claro. Atualizando a interface do usu√°rio. Ol√° navegador, estou adicionando algumas coisas ao DOM.</li>\n<li><strong>Navegador</strong>: Legal, eu pintei para a tela.</li>\n<li>\n<p><strong>React</strong>: OK, agora vou executar o efeito que voc√™ me deu.</p>\n<ul>\n<li>Executando: <code>() => { document.title = 'You clicked 0 times' }</code>.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>Agora vamos recapitular o que acontece depois que clicamos:</p>\n<ul>\n<li><strong>Seu componente</strong>: Ei React, defina meu estado como <code>1</code>.</li>\n<li><strong>React</strong>: Me retorna a interface do usu√°rio quando o estado √© <code>1</code></li>\n<li>\n<p><strong>Seu componente</strong>:</p>\n<ul>\n<li>Aqui est√° o resultado da renderiza√ß√£o: <code>&#x3C;p>You clicked 1 times&#x3C;/p></code>.</li>\n<li>Lembre-se de executar este efeito depois que voc√™ estiver pronto: <code>() => { document.title = 'You clicked 1 times' }</code>.</li>\n</ul>\n</li>\n<li><strong>React</strong>: Claro. Atualizando a interface do usu√°rio. Ei navegador, eu mudei o DOM.</li>\n<li><strong>Navegador</strong>: Legal, eu pintei suas altera√ß√µes na tela.</li>\n<li>\n<p><strong>React</strong>: OK, agora eu vou executar o efeito que pertence a rendereriza√ß√£o que acabei de fazer.</p>\n<ul>\n<li>Executando: <code>() => { document.title = 'You clicked 1 times' }</code>.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2>Cada renderiza√ß√£o tem seu pr√≥prio... tudo</h2>\n<p><strong>Sabemos agora que os efeitos s√£o executados ap√≥s cada renderiza√ß√£o, s√£o conceitualmente parte da sa√≠da do componente e ‚Äúveem‚Äù os objetos e o estado a partir dessa renderiza√ß√£o espec√≠fica.</strong></p>\n<p>Vamos tentar um experimento mental. Considere este c√≥digo:</p>\n<pre><code class=\"language-jsx{4-8}\">function Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    setTimeout(() => {\n      console.log(`You clicked ${count} times`);\n    }, 3000);\n  });\n\n  return (\n    &#x3C;div>\n      &#x3C;p>You clicked {count} times&#x3C;/p>\n      &#x3C;button onClick={() => setCount(count + 1)}>\n        Click me\n      &#x3C;/button>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>Se eu clicar v√°rias vezes com um pequeno <em>delay</em>, como o log de registros ir√° ficar?</p>\n<hr>\n<p><em>spoilers √† frente</em></p>\n<hr>\n<p>Voc√™ pode pensar que isso √© uma pegadinha e o resultado final n√£o √© intuitivo. N√£o √©! Vamos ver uma sequ√™ncia de logs - cada um pertencente a uma renderiza√ß√£o espec√≠fica e, portanto, com seu pr√≥prio valor de <code>count</code>. <a href=\"https://codesandbox.io/s/lyx20m1ol\">Voc√™ pode tentar aqui</a>:</p>\n<p><img src=\"./timeout_counter.gif\" alt=\"Grava√ß√£o da tela com logs 1, 2, 3, 4, 5 em ordem\"></p>\n<p>Voc√™ pode pensar: ‚ÄúClaro que √© assim que funciona! De que outra forma poderia funcionar?</p>\n<p>Bem, n√£o √© assim que <code>this.state</code> funciona em <code>class</code>. √â f√°cil cometer o erro de pensar que <a href=\"https://codesandbox.io/s/kkymzwjqz3\">essa implementa√ß√£o</a> √© equivalente em <code>class</code>:</p>\n<pre><code class=\"language-jsx\">  componentDidUpdate() {\n    setTimeout(() => {\n      console.log(`You clicked ${this.state.count} times`);\n    }, 3000);\n  }\n</code></pre>\n<p>No entanto, <code>this.state.count</code> sempre aponta para a contagem mais recente ao inv√©s da que pertence a uma renderiza√ß√£o espec√≠fica. Ent√£o, voc√™ ver√° <code>5</code> nos logs:</p>\n<p><img src=\"./timeout_counter_class.gif\" alt=\"Grava√ß√£o da tela com logs 5, 5, 5, 5, 5 em ordem\"></p>\n<p>Eu acho ir√¥nico que os Hooks dependam tanto de <strong>closures</strong> em JavaScript, e ainda assim, √© a implementa√ß√£o de classes que sofre com <a href=\"https://wsvincent.com/javascript-closure-settimeout-for-loop/\">a confus√£o can√¥nica de valores errados em temporizadores</a> que √© freq√ºentemente associada com <strong>closures</strong>. Isso ocorre porque a fonte real da confus√£o neste exemplo √© a muta√ß√£o (o React faz muta√ß√£o em <code>this.state</code> nas classes para apontar para o estado mais recente) e n√£o na <strong>closures</strong> em si.</p>\n<p><strong>Closures s√£o √≥timas quando os valores que voc√™ encapsula nunca mudam. Isso os torna f√°ceis de se pensar porque voc√™ est√° essencialmente se referindo a uma constante.</strong> E como discutimos, <em>props</em> e <em>state</em> nunca mudam dentro de uma renderiza√ß√£o espec√≠fica. A prop√≥sito, podemos consertar a vers√£o de classe...utilizando <a href=\"https://codesandbox.io/s/w7vjo07055\">uma <strong>closure</strong></a>.</p>\n<h2>Nadando contra a mar√©</h2>\n<p>Neste ponto, √© importante falar explicitamente: cada fun√ß√£o dentro da renderiza√ß√£o do componente (incluindo manipuladores de eventos, efeitos, temporizadores ou chamadas de API dentro delas) capturam <em>props</em> e <em>state</em> da chamada de renderiza√ß√£o que a definiu.</p>\n<p>Ent√£o, esses dois exemplos s√£o equivalentes:</p>\n<pre><code class=\"language-jsx{4}\">function Example(props) {\n  useEffect(() => {\n    setTimeout(() => {\n      console.log(props.counter);\n    }, 1000);\n  });\n  // ...\n}\n</code></pre>\n<pre><code class=\"language-jsx{2,5}\">function Example(props) {\n  const counter = props.counter;\n  useEffect(() => {\n    setTimeout(() => {\n      console.log(counter);\n    }, 1000);\n  });\n  // ...\n}\n</code></pre>\n<p><strong>N√£o importa se voc√™ l√™ as <em>props</em> ou as declara mais \"cedo\" dentro do seu componente.</strong> Elas n√£o v√£o mudar! Dentro do escopo de uma √∫nica renderiza√ß√£o, as <em>props</em> e <em>state</em> permanecem as mesmas. (desestruturando as <em>props</em> tornam isso mais √≥bvio.)</p>\n<p>Naturalmente, √†s vezes voc√™ deseja ler o valor mais recente ao inv√©s do que foi capturado, talvez em algum retorno de chamada definido em um efeito. A maneira mais f√°cil de fazer isso √© usando refs, conforme descrito na √∫ltima se√ß√£o <a href=\"https://overreacted.io/how-are-function-components-different-from-classes/\">deste artigo</a>.</p>\n<p>Fique ciente de que quando voc√™ quiser ler as <em>props</em> futuras, ou <em>state</em> de uma fun√ß√£o em uma renderiza√ß√£o passada, voc√™ estar√° nadando contra a mar√©. N√£o √© errado (e, em alguns casos, necess√°rio), mas isso pode parecer menos \"limpo\", ao sair do paradigma. Essa √© uma consequ√™ncia intencional porque ajuda a destacar qual c√≥digo √© fr√°gil e depende de um tempo espec√≠fico. Nas <strong>class</strong>, √© menos √≥bvio quando isso acontece.</p>\n<p>Aqui est√° uma <a href=\"https://codesandbox.io/s/rm7z22qnlp\">vers√£o do nosso contador</a> que replica o comportamento da classe:</p>\n<pre><code class=\"language-jsx{3,6-7,9-10}\">function Example() {\n  const [count, setCount] = useState(0);\n  const latestCount = useRef(count);\n\n  useEffect(() => {\n    // Define o √∫ltimo valor por muta√ß√£o\n    latestCount.current = count;\n    setTimeout(() => {\n      // Lendo o √∫ltimo valor da muta√ß√£o\n      console.log(`You clicked ${latestCount.current} times`);\n    }, 3000);\n  });\n  // ...\n</code></pre>\n<p><img src=\"./timeout_counter_refs.gif\" alt=\"Grava√ß√£o da tela com logs 5, 5, 5, 5, 5 em ordem\"></p>\n<p>Pode parecer estranho mutar algo em React. No entanto, √© exatamente assim que o pr√≥prio React reatribui <code>this.state</code> em classes. Ao contr√°rio das <em>props</em> e <em>state</em> capturadas, voc√™ n√£o tem nenhuma garantia de que a leitura <code>latestCount.current</code> forne√ßa o mesmo valor em qualquer chamada de retorno espec√≠fica. Por defini√ß√£o, voc√™ pode alter√°-lo a qualquer momento. √â por isso que n√£o √© um padr√£o, e voc√™ tem que optar manualmente por isso.</p>\n<h2>Ent√£o, o que acontece no momento de limpeza?</h2>\n<p>Como <a href=\"https://reactjs.org/docs/hooks-effect.html#effects-with-cleanup\">a documenta√ß√£o explica</a>, alguns efeitos podem ter uma fase de limpeza. Essencialmente, sua finalidade √© \"desfazer\" um efeito para casos como <strong>subscriptions</strong>.</p>\n<p>Considere este c√≥digo:</p>\n<pre><code class=\"language-jsx\">  useEffect(() => {\n    ChatAPI.subscribeToFriendStatus(props.id, handleStatusChange);\n    return () => {\n      ChatAPI.unsubscribeFromFriendStatus(props.id, handleStatusChange);\n    };\n  });\n</code></pre>\n<p>Vamos supor que <em>props</em> est√° em <code>{id: 10}</code> na primeira renderiza√ß√£o e <code>{id: 20}</code> na segunda. Voc√™ pode pensar que algo assim acontece:</p>\n<ul>\n<li>React limpa o efeito para <code>{id: 10}</code></li>\n<li>React renderiza a interface do usu√°rio para <code>{id: 20}</code></li>\n<li>React executa o efeito para <code>{id: 20}</code></li>\n</ul>\n<p>(Esse n√£o √© bem o caso.)</p>\n<p>Com este modelo mental, voc√™ pode pensar que a limpeza ‚Äúv√™‚Äù os objetos antigos porque ela executa antes de renderizar novamente, e ent√£o o novo efeito ‚Äúv√™‚Äù as novas <em>props</em> porque executa ap√≥s a re-renderiza√ß√£o. Esse √© o modelo mental diretamente relacionado aos ciclos de vida das classes, e <strong>n√£o √© preciso nesse caso</strong>. Vamos ver o porque.</p>\n<p>React apenas executa os efeitos <a href=\"https://medium.com/@dan_abramov/this-benchmark-is-indeed-flawed-c3d6b5b6f97f\">depois de deixar o navegador pintar as altera√ß√µes na tela</a>. Isso torna seu aplicativo mais r√°pido, pois a maioria dos efeitos n√£o precisa bloquear as atualiza√ß√µes de tela. A limpeza do efeito tamb√©m √© atrasada. <strong>O efeito anterior √© limpo <em>ap√≥s</em> a nova renderiza√ß√£o com novas <em>props</em></strong>:</p>\n<ul>\n<li><strong>React renderiza a interface do usu√°rio para <code>{id: 20}</code>.</strong></li>\n<li>O navegador pinta a tela. N√≥s vemos a interface do usu√°rio para <code>{id: 20}</code>na tela.</li>\n<li><strong>React limpa o efeito para <code>{id: 10}</code>.</strong></li>\n<li>React executa o efeito para <code>{id: 20}</code>.</li>\n</ul>\n<p>Voc√™ pode estar se perguntando: mas como a limpeza do efeito anterior ainda pode ‚Äúver‚Äù as <em>props</em> <code>{id: 10}</code> se ele foi executado depois que os adere√ßos mudaram para <code>{id: 20}</code>?</p>\n<p>N√≥s estivemos aqui antes...ü§î</p>\n<p><img src=\"./deja_vu.gif\" alt=\"D√©j√† vu (cena do gato do filme Matrix)\"></p>\n<p>Citando a se√ß√£o anterior:</p>\n<blockquote>\n<p>Todas as fun√ß√µes dentro da renderiza√ß√£o do componente (incluindo manipuladores de eventos, efeitos, temporizadores ou chamadas de API dentro delas) capturam <em>props</em> e <em>state</em> da chamada de renderiza√ß√£o que a definiu.</p>\n</blockquote>\n<p>Agora a resposta √© clara! A limpeza do efeito n√£o l√™ as <em>props</em> \"mais recentes\", o que quer que isso signifique. Ela l√™ as <em>props</em> que pertencem √† renderiza√ß√£o que a definiu:</p>\n<pre><code class=\"language-jsx{8-11}\">// Primeira renderiza√ß√£o, props s√£o {id: 10}\nfunction Example() {\n  // ...\n  useEffect(\n    // Efeito da primeirza renderiza√ß√£o\n    () => {\n      ChatAPI.subscribeToFriendStatus(10, handleStatusChange);\n      // Limpeza para o efeito da primeira renderiza√ß√£o\n      return () => {\n        ChatAPI.unsubscribeFromFriendStatus(10, handleStatusChange);\n      };\n    }\n  );\n  // ...\n}\n\n// Pr√≥xima renderiza√ß√£o, props s√£o {id: 20}\nfunction Example() {\n  // ...\n  useEffect(\n    // Efeito da segunda renderiza√ß√£o\n    () => {\n      ChatAPI.subscribeToFriendStatus(20, handleStatusChange);\n      // Limpeza para o efeito da segunda renderiza√ß√£o\n      return () => {\n        ChatAPI.unsubscribeFromFriendStatus(20, handleStatusChange);\n      };\n    }\n  );\n  // ...\n}\n</code></pre>\n<p>Reinos se elevar√£o e se transformar√£o em cinzas, o Sol ir√° ejetar suas camadas externas e se tornar uma <a href=\"https://pt.wikipedia.org/wiki/An%C3%A3_branca\">an√£ branca</a> e a √∫ltima civiliza√ß√£o terminar√°. Mas nada far√° com que as <em>props</em> utilizadas pela etapa de limpeza da primeira renderiza√ß√£o sejam outras do que <code>{id: 10}</code>.</p>\n<p>Isso √© o que permite que o React lide com os efeitos logo ap√≥s a pintura - tornando seus aplicativos mais r√°pidos por padr√£o. As <em>props</em> antigas ainda est√£o l√°, se o nosso c√≥digo precisar delas.</p>\n<h2>Sincroniza√ß√£o, n√£o Ciclos de Vida</h2>\n<p>Uma das minhas coisas favoritas sobre o React √© que ele unifica a descri√ß√£o do resultado inicial da renderiza√ß√£o e das atualiza√ß√µes. Isso <a href=\"https://overreacted.io/the-bug-o-notation/\">reduz a entropia do seu programa</a>.</p>\n<p>Digamos que meu componente √© o seguinte:</p>\n<pre><code class=\"language-jsx\">function Greeting({ name }) {\n  return (\n    &#x3C;h1 className=\"Greeting\">\n      Hello, {name}\n    &#x3C;/h1>\n  );\n}\n</code></pre>\n<p>N√£o importa se eu renderizo <code>&#x3C;Greeting name=\"Dan\" /></code> e depois <code>&#x3C;Greeting name=\"Yuzhi\" /></code>, ou se apenas renderizo <code>&#x3C;Greeting name=\"Yuzhi\" /></code>. No final, vamos ver <code>\"Hello, Yuzhi\"</code> em ambos os casos.</p>\n<p>As pessoas dizem: \"√â tudo sobre a jornada, n√£o o destino\". Com React, √© o oposto. <strong>√â tudo sobre o destino, n√£o a jornada</strong>. Essa √© a diferen√ßa entre as chamadas <code>$.addClass</code> e <code>$.removeClass</code> no c√≥digo jQuery (nossa \"jornada\") e especificando <em>qual deve</em> ser a classe CSS no c√≥digo React (nosso \"destino\").</p>\n<p><strong>React sincroniza o DOM de acordo com nossas <em>props</em> e <em>state</em> atuais.</strong> N√£o h√° distin√ß√£o entre uma \"montagem\" ou uma \"atualiza√ß√£o\" durante a renderiza√ß√£o.</p>\n<p>Voc√™ deve pensar nos efeitos de maneira semelhante. <strong><code>useEffect</code> permite sincronizar as coisas fora da √°rvore do React de acordo com as nossas <em>props</em> e <em>state</em></strong>.</p>\n<pre><code class=\"language-jsx{2-4}\">function Greeting({ name }) {\n  useEffect(() => {\n    document.title = 'Hello, ' + name;\n  });\n  return (\n    &#x3C;h1 className=\"Greeting\">\n      Hello, {name}\n    &#x3C;/h1>\n  );\n}\n</code></pre>\n<p>Isso √© sutilmente diferente do modelo mental familiar de montagem/atualiza√ß√£o/desmontagem. <strong>√â importante realmente internalizar isso. Se voc√™ est√° tentando escrever um efeito que se comporta de maneira diferente dependendo se o componente renderiza pela primeira vez ou n√£o, voc√™ est√° nadando contra a mar√©!</strong> Falhamos em sincronizar se nosso resultado depende da \"jornada\" e n√£o do \"destino\".</p>\n<p>N√£o importa se renderizamos com as <em>props</em> A, B e C, ou se renderizamos com C imediatamente. Embora possa haver algumas diferen√ßas tempor√°rias (por exemplo, enquanto estamos buscando dados), eventualmente, o resultado final deve ser o mesmo.</p>\n<p>Ainda assim, √© claro que executar todos os efeitos em cada render pode n√£o ser eficiente. (E em alguns casos, isso levaria a loops infinitos.)</p>\n<p>Ent√£o, como podemos consertar isso?</p>\n<h2>Ensinando React a diferenciar seus efeitos</h2>\n<p>N√≥s j√° aprendemos essa li√ß√£o com o pr√≥prio DOM. Ao inv√©s de alter√°-lo em cada nova renderiza√ß√£o, o React s√≥ atualiza as partes do DOM que realmente mudam.</p>\n<p>Quando voc√™ est√° atualizando:</p>\n<pre><code class=\"language-jsx\">&#x3C;h1 className=\"Greeting\">\n  Hello, Dan\n&#x3C;/h1>\n</code></pre>\n<p>Para:</p>\n<pre><code class=\"language-jsx\">&#x3C;h1 className=\"Greeting\">\n  Hello, Yuzhi\n&#x3C;/h1>\n</code></pre>\n<p>React v√™ dois objetos:</p>\n<pre><code class=\"language-jsx\">const oldProps = {className: 'Greeting', children: 'Hello, Dan'};\nconst newProps = {className: 'Greeting', children: 'Hello, Yuzhi'};\n</code></pre>\n<p>React verifica cada uma de suas <em>props</em> e determina que <code>children</code> mudou e por isso, precisa realizar uma atualiza√ß√£o no DOM, mas <code>className</code> n√£o mudou. Ent√£o, ele pode apenas fazer:</p>\n<pre><code class=\"language-jsx\">domNode.innerText = 'Hello, Yuzhi';\n// N√£o precisa tocar `domNode.className`\n</code></pre>\n<p><strong>Podemos fazer algo assim com efeitos tamb√©m? Seria bom evitar sua execu√ß√£o quando desnecess√°rio.</strong></p>\n<p>Por exemplo, talvez nosso componente renderize novamente devido a uma altera√ß√£o de estado:</p>\n<pre><code class=\"language-jsx{11-13}\">function Greeting({ name }) {\n  const [counter, setCounter] = useState(0);\n\n  useEffect(() => {\n    document.title = 'Hello, ' + name;\n  });\n\n  return (\n    &#x3C;h1 className=\"Greeting\">\n      Hello, {name}\n      &#x3C;button onClick={() => setCounter(count + 1)}>\n        Increment\n      &#x3C;/button>\n    &#x3C;/h1>\n  );\n}\n</code></pre>\n<p>Mas nosso efeito n√£o usa o estado <code>counter</code>. <strong>Nosso efeito sincroniza o <code>document.title</code> com a prop <code>name</code>, mas nesse caso, a prop <code>name</code> √© a mesma</strong>. Reatribuir <code>document.title</code> em cada mudan√ßa de <code>counter</code> n√£o √© ideal.</p>\n<p>Certo, ent√£o... React pode checar a diferen√ßa em efeitos?</p>\n<pre><code class=\"language-jsx\">let oldEffect = () => { document.title = 'Hello, Dan'; };\nlet newEffect = () => { document.title = 'Hello, Dan'; };\n// O React pode ver entender que essas fun√ß√µes fazem a mesma coisa?\n</code></pre>\n<p>Na verdade n√£o. React n√£o pode adivinhar o que a fun√ß√£o faz sem cham√°-la. (O c√≥digo fonte realmente n√£o cont√©m valores espec√≠ficos, apenas encapsula a prop <code>name</code>.)</p>\n<p>√â por isso que, se voc√™ quiser evitar a repeti√ß√£o desnecess√°rias de efeitos, voc√™ pode fornecer um array de depend√™ncias como segundo argumento (tamb√©m conhecido como \"deps\") para <code>useEffect</code>:</p>\n<pre><code class=\"language-jsx{3}\">  useEffect(() => {\n    document.title = 'Hello, ' + name;\n  }, [name]); // Nossas \"deps\"\n</code></pre>\n<p><strong>√â como dizer ao React: \"Ei, eu sei que voc√™ n√£o pode \"ver\" dentro desta fun√ß√£o, mas eu prometo que s√≥ a prop <code>name</code> √© usada do escopo de renderiza√ß√£o e nada mais.\"</strong></p>\n<p>Se cada um desses valores for o mesmo entre a renderiza√ß√£o atual e a anterior, esse efeito n√£o ser√° sincronizado, portanto, o React pode pular o efeito:</p>\n<pre><code class=\"language-jsx\">const oldEffect = () => { document.title = 'Hello, Dan'; };\nconst oldDeps = ['Dan'];\n\nconst newEffect = () => { document.title = 'Hello, Dan'; };\nconst newDeps = ['Dan'];\n\n// React n√£o pode \"olhar\" dentro de fun√ß√µes, apenas em \"deps\"\n// Como todas as \"deps\" s√£o as mesmas, ele n√£o precisa executar o efeito\n</code></pre>\n<p>Se mesmo um dos valores do array de depend√™ncias for diferente entre renderiza√ß√µes, sabemos que a execu√ß√£o do efeito n√£o ser√° ignorada. Sincronizando todas as coisas!</p>\n<h2>Mentir para o React sobre suas \"deps\" pode causar problemas</h2>\n<p>Mentir para o React sobre suas \"deps\" tem consequ√™ncias ruins. Intuitivamente, isso faz sentido, mas eu vi praticamente todo mundo que tenta usar <code>useEffect</code> com um modelo mental das <code>class</code>, tenta enganar as regras! (E eu fiz isso tamb√©m no come√ßo!)</p>\n<pre><code class=\"language-jsx\">function SearchResults() {\n  async function fetchData() {\n    // ...\n  }\n\n  useEffect(() => {\n    fetchData();\n  }, []); // Isso √© certo? Nem sempre -- e tem um jeito melhor de escrever isso.\n\n  // ...\n}\n</code></pre>\n<p><em>(O <a href=\"https://reactjs.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies\">FAQ dos Hooks explica</a> o que fazer ao inv√©s do exemplo acima. <a href=\"https://overreacted.io/a-complete-guide-to-useeffect/#moving-functions-inside-effects\">Voltaremos nesse exemplo</a> mais para frente.)</em></p>\n<p>\"Mas eu s√≥ quero executar isso ao montar o componente!\", Voc√™ dir√°. Por enquanto, lembre-se: se voc√™ especificar \"deps\", <strong>todos os valores de dentro de seu componente que s√£o usados ‚Äã‚Äãpelo efeito devem ser listados l√°</strong>. Incluindo <em>props</em>, <em>state</em>, fun√ß√µes - qualquer coisa no escopo do seu componente usado dentro do efeito.</p>\n<p>√Äs vezes, quando voc√™ faz isso, isso causa algum problema. Por exemplo, talvez voc√™ veja um loop de infinito ao buscar dados ou um <strong>socket</strong> √© recriado com muita freq√º√™ncia. <strong>A solu√ß√£o para esse problema n√£o √© remover a depend√™ncia</strong> e iremos ver as solu√ß√µes em breve.</p>\n<p>Mas antes de pularmos para as solu√ß√µes, vamos entender melhor o problema.</p>\n<h2>O que acontece se mentirmos na nossa lista de \"deps\"</h2>\n<p>Se na nossa lista de \"deps\" estiverem todos os valores usados ‚Äã‚Äãpelo efeito, o React saber√° quando execut√°-lo novamente:</p>\n<pre><code class=\"language-jsx{3}\">  useEffect(() => {\n    document.title = 'Hello, ' + name;\n  }, [name]);\n</code></pre>\n<p><img src=\"./deps-compare-correct.gif\" alt=\"Diagrama de efeitos substituindo uns aos outros\"></p>\n<p><em>(Quando as depend√™ncias s√£o diferentes, n√≥s executamos novamente o efeito.)</em></p>\n<p>Mas se especificamos <code>[]</code> para este efeito, a nova fun√ß√£o de efeito n√£o seria executada:</p>\n<pre><code class=\"language-jsx{3}\">  useEffect(() => {\n    document.title = 'Hello, ' + name;\n  }, []); // Errado: `name` est√° faltando na lista de \"deps\"\n</code></pre>\n<p><img src=\"./deps-compare-wrong.gif\" alt=\"Diagrama de efeitos substituindo uns aos outros\"></p>\n<p><em>(Como as depend√™ncias s√£o iguais, n√≥s pulamos o efeito.)</em></p>\n<p>Nesse caso, o problema pode parecer √≥bvio. Mas a intui√ß√£o pode engan√°-lo em outros casos, especialmente se sua mem√≥ria muscular lembrar de solu√ß√µes com <em>class</em>.</p>\n<p>Por exemplo, digamos que estamos escrevendo um contador que aumenta a cada segundo. Com <code>class</code>, nossa intui√ß√£o √©: \"Configure o intervalo uma vez e destrua-o uma vez\". Aqui est√° um <a href=\"https://codesandbox.io/s/n5mjzjy9kl\">exemplo</a> de como podemos fazer isso. Quando traduzimos mentalmente esse c√≥digo em <code>useEffect</code>, instintivamente adicionamos <code>[]</code> a lista de \"deps\". ‚ÄúEu quero que seja executado uma vez‚Äù, certo?</p>\n<pre><code class=\"language-jsx{9}\">function Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      setCount(count + 1);\n    }, 1000);\n    return () => clearInterval(id);\n  }, []);\n\n  return &#x3C;h1>{count}&#x3C;/h1>;\n}\n</code></pre>\n<p>No entanto, este exemplo <a href=\"https://codesandbox.io/s/91n5z8jo7r\">s√≥ incrementa uma vez</a>. <em>Oops.</em></p>\n<p>Se o seu modelo mental √© ‚Äúdepend√™ncias, deixe-me especificar quando quero reativar o efeito‚Äù, este exemplo pode dar a voc√™ uma crise existencial. Voc√™ <em>quer</em> acion√°-lo uma vez porque √© um intervalo - ent√£o por que ele est√° causando problemas?</p>\n<p>No entanto, isso faz sentido se voc√™ sabe que a lista de depend√™ncias s√£o nossas dicas para o React sobre <em>tudo</em> o que o efeito usa do escopo de renderiza√ß√£o. Ele usa, <code>count</code>, mas n√≥s mentimos para o React, dizendo que isso n√£o acontece com <code>[]</code>. √â s√≥ uma quest√£o de tempo antes que isso nos morde de volta!</p>\n<p>Na primeira renderiza√ß√£o, <code>count</code> √© <code>0</code>. Portanto, <code>setCount(count + 1)</code> no primeiro efeito de renderiza√ß√£o significa <code>setCount(0 + 1)</code>. <strong>Como nunca executamos novamente o efeito por causa das \"deps\" <code>[]</code>, ele continuar√° chamando <code>setCount(0 + 1)</code> cada segundo:</strong></p>\n<pre><code class=\"language-jsx{8,12,21-22}\">// Primeira renderiza√ß√£o, `state` √© 0\nfunction Counter() {\n  // ...\n  useEffect(\n    // Efeito da primeira renderiza√ß√£o\n    () => {\n      const id = setInterval(() => {\n        setCount(0 + 1); // Always setCount(1)\n      }, 1000);\n      return () => clearInterval(id);\n    },\n    [] // Nunca re-execute o efeito\n  );\n  // ...\n}\n\n// Toda renderiza√ß√£o subsequente, `state` √© 1\nfunction Counter() {\n  // ...\n  useEffect(\n    // Esse efeito √© sempre ignorado porque\n    // n√≥s mentimos para o React sobre a lista\n    // em branco de depend√™ncias\n    () => {\n      const id = setInterval(() => {\n        setCount(1 + 1);\n      }, 1000);\n      return () => clearInterval(id);\n    },\n    []\n  );\n  // ...\n}\n</code></pre>\n<p>N√≥s mentimos para o React dizendo que nosso efeito n√£o depende de um valor de dentro de nosso componente, quando na verdade ele depende!</p>\n<p>Nosso efeito usa <code>count</code> - um valor dentro do escopo de renderiza√ß√£o do componente, por√©m fora do efeito:</p>\n<pre><code class=\"language-jsx{1,5}\">  const count = // ...\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      setCount(count + 1);\n    }, 1000);\n    return () => clearInterval(id);\n  }, []);\n</code></pre>\n<p>Portanto, especificar <code>[]</code> como uma depend√™ncia criar√° um erro. O React ir√° comparar as depend√™ncias e pular√° a atualiza√ß√£o desse efeito:</p>\n<p><img src=\"./interval-wrong.gif\" alt=\"Diagrama da closure do intervalo j√° obsoleto\"></p>\n<p><em>(As depend√™ncias s√£o iguais, ent√£o pulamos o efeito.)</em></p>\n<p>Quest√µes como essa s√£o dif√≠ceis de se pensar. Portanto, eu te encorajo a adotar como uma regra rigorosa de sempre ser honesto sobre suas depend√™ncias de efeito e especificar todas elas. Fornecemos <a href=\"https://github.com/facebook/react/issues/14920\">uma regra no linter</a> se voc√™ quiser impor isso ao seu time.</p>\n<h2>Duas maneiras de ser honesto sobre suas depend√™ncias</h2>\n<p>Existem duas estrat√©gias para ser honesto sobre suas depend√™ncias. Geralmente, voc√™ deve come√ßar com o primeiro e depois aplicar o segundo, se necess√°rio.</p>\n<p><strong>A primeira estrat√©gia √© arrumar o array de depend√™ncias para incluir todos os valores do escopo do componente que s√£o usados ‚Äã‚Äãdentro do efeito.</strong> Vamos incluir <code>count</code>:</p>\n<pre><code class=\"language-jsx{3,6}\">useEffect(() => {\n  const id = setInterval(() => {\n    setCount(count + 1);\n  }, 1000);\n  return () => clearInterval(id);\n}, [count]);\n</code></pre>\n<p>Isso faz com que o array de depend√™ncias fique correto. Pode n√£o ser <em>ideal</em>, mas esse √© o primeiro problema que precisamos corrigir. Agora, uma mudan√ßa em <code>count</code> ir√° executar o efeito novamente, com cada pr√≥ximo intervalo referenciando <code>count</code> do escopo de renderiza√ß√£o do seu component em <code>setCount(count + 1)</code>:</p>\n<pre><code class=\"language-jsx{8,12,24,28}\">// Primeira renderiza√ß√£o, `state` √© 0\nfunction Counter() {\n  // ...\n  useEffect(\n    // Efeito na primeira renderiza√ß√£o\n    () => {\n      const id = setInterval(() => {\n        setCount(0 + 1); // setCount(count + 1)\n      }, 1000);\n      return () => clearInterval(id);\n    },\n    [0] // [count]\n  );\n  // ...\n}\n\n// Segunda renderiza√ß√£o, `state` √© 1\nfunction Counter() {\n  // ...\n  useEffect(\n    // Effect from second render\n    () => {\n      const id = setInterval(() => {\n        setCount(1 + 1); // setCount(count + 1)\n      }, 1000);\n      return () => clearInterval(id);\n    },\n    [1] // [count]\n  );\n  // ...\n}\n</code></pre>\n<p>Isso <a href=\"https://codesandbox.io/s/0x0mnlyq8l\">resolveria o problema</a>, mas nosso intervalo seria limpo e definido novamente sempre que altera√ß√µes no <code>count</code> fossem feitas. Isso pode ser indesej√°vel:</p>\n<p><img src=\"./interval-rightish.gif\" alt=\"Diagrama do intervalo que se reinscreve\"></p>\n<p><em>(As depend√™ncias s√£o diferentes, ent√£o executamos novamente o efeito.)</em></p>\n<hr>\n<p><strong>A segunda estrat√©gia √© alterar o c√≥digo do nosso efeito para que ele n√£o <em>precise</em> de um valor que mude com mais frequ√™ncia do que desejamos.</strong> N√≥s n√£o queremos mentir sobre as depend√™ncias - apenas queremos que nosso efeito tenha menos depend√™ncias.</p>\n<p>Vamos ver algumas t√©cnicas comuns para remover depend√™ncias.</p>\n<hr>\n<h2>Tornando os Efeitos Auto-Suficientes</h2>\n<p>Queremos nos livrar de <code>count</code> na lista de depend√™ncias em nosso efeito:</p>\n<pre><code class=\"language-jsx{3,6}\">  useEffect(() => {\n    const id = setInterval(() => {\n      setCount(count + 1);\n    }, 1000);\n    return () => clearInterval(id);\n  }, [count]);\n</code></pre>\n<p>Para fazer isso, precisamos nos perguntar: para que estamos utilizando <code>count</code>? Parece que s√≥ usamos para a chamada de <code>setCount</code>. E para esse caso, realmente n√£o precisamos de <code>count</code>. Quando queremos atualizar o estado com base no estado anterior, podemos usar <a href=\"https://reactjs.org/docs/hooks-reference.html#functional-updates\">a forma funcional</a> do <code>setState</code>:</p>\n<pre><code class=\"language-jsx{3}\">  useEffect(() => {\n    const id = setInterval(() => {\n      setCount(c => c + 1);\n    }, 1000);\n    return () => clearInterval(id);\n  }, []);\n</code></pre>\n<p>Eu gosto de pensar nesses casos como \"falsas depend√™ncias\". Sim, <code>count</code> foi uma depend√™ncia necess√°ria porque escrevemos <code>setCount(count + 1)</code> dentro do efeito. No entando, n√≥s s√≥ precis√°vamos de <code>count</code> para transform√°-lo em <code>count + 1</code> e \"enviar de volta\" para o React. Mas o React <em>j√° conhece</em> o atual valor de <code>count</code>. <strong>O que precisamos dizer ao React √© que ele incremente o estado - qualquer que seja seu valor atual.</strong></p>\n<p>Isso √© exatamente o que <code>setCount(c => c + 1)</code> faz. Voc√™ pode pensar nisso como \"enviar uma instru√ß√£o\" para o React de como o estado deve mudar. Essa \"forma funcional\" tamb√©m ajuda em outros casos, como quando voc√™ faz <a href=\"https://overreacted.io/react-as-a-ui-runtime/#batching\">atualiza√ß√µes em lotes</a>.</p>\n<p><strong>Perceba que n√≥s realmente <em>fizemos o trabalho</em> para remover a depend√™ncia. N√≥s n√£o trapace√°mos. Nosso efeito n√£o l√™ mais o valor <code>count</code> do escopo de renderiza√ß√£o:</strong></p>\n<p><img src=\"./interval-right.gif\" alt=\"Diagrama do interval que funciona\"></p>\n<p><em>(As depend√™ncias s√£o iguais, ent√£o pulamos o efeito.)</em></p>\n<p>Voc√™ pode <a href=\"https://codesandbox.io/s/q3181xz1pj\">tentar aqui</a>.</p>\n<p>Embora esse efeito seja executado apenas uma vez, o retorno de chamada do intervalo que definimos pertencente √† primeira renderiza√ß√£o, √© perfeitamente capaz de enviar a instru√ß√£o de atualiza√ß√£o<code>c => c + 1</code>  toda vez que o intervalo √© disparado. N√£o precisamos mais saber o estado atual de <code>count</code>. React j√° o conhece.</p>\n<h2>Atualiza√ß√µes Funcionais e Google Docs</h2>\n<p>Lembra que falamos sobre sincroniza√ß√£o sendo o modelo mental para efeitos? Um aspecto interessante da sincroniza√ß√£o √© que muitas vezes voc√™ deseja manter as \"mensagens\" entre os sistemas separados de seu estado. Por exemplo, editar um documento no Google Docs n√£o envia a <em>p√°gina inteira</em> para o servidor. Isso seria muito ineficiente. Ao inv√©s disso, ele envia uma representa√ß√£o do que o usu√°rio tentou fazer.</p>\n<p>Embora nosso caso de uso seja diferente, uma filosofia semelhante se aplica aos efeitos. <strong>Precisamos enviar apenas as informa√ß√µes m√≠nimas necess√°rias de dentro dos efeitos para um componente.</strong> O atualizador <code>setCount(c => c + 1)</code>, por exemplo, tem menos informa√ß√µes do que <code>setCount(count + 1)</code> porque ele n√£o est√° \"contaminado\" pela contagem atual. Ele apenas expressa a a√ß√£o desejada (\"incrementar\"). Pensar em React <a href=\"https://reactjs.org/docs/thinking-in-react.html#step-3-identify-the-minimal-but-complete-representation-of-ui-state\">envolve encontrar o estado m√≠nimo</a>. √â o mesmo princ√≠pio, mas para atualiza√ß√µes.</p>\n<p>Codificar a <em>inten√ß√£o</em> (ao inv√©s do resultado) √© semelhante a como o Google Docs <a href=\"https://medium.com/@srijancse/how-real-time-collaborative-editing-work-operational-transformation-ac4902d75682\">resolve</a> a edi√ß√£o colaborativa. Embora tenhamos ampliando a analogia, as atualiza√ß√µes funcionais desempenham um papel semelhante no React. Eles garantem que atualiza√ß√µes de v√°rias fontes (manipuladores de eventos, assinaturas de efeitos, etc) possam ser aplicadas corretamente em um lote e de maneira previs√≠vel.</p>\n<p><strong>No entanto, <code>setCount(c => c + 1)</code> n√£o √© √≥timo.</strong> Parece um pouco estranho e √© muito limitado no que pode ele fazer. Por exemplo, se tiv√©ssemos duas vari√°veis ‚Äã‚Äãde estado cujos valores dependessem uns dos outros, ou se precisarmos calcular o pr√≥ximo estado com base em uma <em>prop</em>, isso n√£o nos ajudaria. Felizmente, <code>setCount(c => c + 1)</code> tem um padr√£o poderoso. Seu nome √© <code>useReducer</code>.</p>\n<h2>Desacoplando Atualiza√ß√µes de A√ß√µes</h2>\n<p>Vamos modificar o exemplo anterior para ter duas vari√°veis ‚Äã‚Äãde estado: <code>count</code> e <code>step</code>. Nosso intervalo ir√° incrementar o valor de <code>count</code> pelo valor de entrada do <code>step</code>:</p>\n<pre><code class=\"language-jsx{7,10}\">function Counter() {\n  const [count, setCount] = useState(0);\n  const [step, setStep] = useState(1);\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      setCount(c => c + step);\n    }, 1000);\n    return () => clearInterval(id);\n  }, [step]);\n\n  return (\n    &#x3C;>\n      &#x3C;h1>{count}&#x3C;/h1>\n      &#x3C;input value={step} onChange={e => setStep(Number(e.target.value))} />\n    &#x3C;/>\n  );\n}\n</code></pre>\n<p>(Aqui est√° uma <a href=\"https://codesandbox.io/s/zxn70rnkx\">demonstra√ß√£o</a> .)</p>\n<p>Note que <strong>n√£o estamos trapaceando</strong>. Desde que comecei a usar <code>step</code> dentro do efeito, eu adicionei ele nas depend√™ncias. E √© por isso que o c√≥digo √© executado corretamente.</p>\n<p>O comportamento atual neste exemplo √© que realizando uma mudan√ßa em <code>step</code>, reinicia o intervalo - porque ele √© uma das depend√™ncias. E em muitos casos, √© exatamente isso que voc√™ quer! N√£o h√° nada de errado em encerrar um efeito e defini-lo de novo, e n√£o devemos evitar isso a menos que tenhamos um bom motivo.</p>\n<p>No entanto, digamos que queremos que o rel√≥gio de intervalo n√£o seja redefinido nas altera√ß√µes para o <code>step</code>. Como removemos <code>step</code> da depend√™ncia do nosso efeito?</p>\n<p><strong>Ao definir uma vari√°vel de estado depende do valor atual de outra vari√°vel de estado, voc√™ pode tentar substituir ambos por <code>useReducer</code>.</strong></p>\n<p>Quando voc√™ se encontrar escrevendo <code>setSomething(something => ...)</code>, √© um bom momento para considerar o uso de um redutor. Um redutor permite <strong>desassociar as \"a√ß√µes\" que ocorreram em seu componente de como o estado √© atualizado.</strong></p>\n<p>Vamos trocar a depend√™ncia <code>step</code> por um <code>dispatch</code> em nosso efeito:</p>\n<pre><code class=\"language-jsx{1,6,9}\">const [state, dispatch] = useReducer(reducer, initialState);\nconst { count, step } = state;\n\nuseEffect(() => {\n  const id = setInterval(() => {\n    dispatch({ type: 'tick' }); // Ao inv√©s de `setCount(c => c + step)`\n  }, 1000);\n  return () => clearInterval(id);\n}, [dispatch]);\n</code></pre>\n<p>(Veja aqui <a href=\"https://codesandbox.io/s/xzr480k0np\">uma demonstra√ß√£o</a>.)</p>\n<p>Voc√™ pode me perguntar: \"Como isso √© melhor?\" A resposta √© que o <strong>React garante que a fun√ß√£o <code>dispatch</code> seja constante durante toda a vida √∫til do componente. Portanto, o exemplo acima nunca precisa reescrever o intervalo.</strong></p>\n<p>N√≥s resolvemos nosso problema!</p>\n<p><em>(Voc√™ pode omitir os valores de <code>dispatch</code>, <code>setState</code> e <code>useRef</code> das \"deps\" porque React garante que eles sejam est√°ticos. Mas tamb√©m n√£o faz mal especific√°-los.)</em></p>\n<p>Ao inv√©s de ler o estado <em>dentro</em> de um efeito, ele envia uma <em>a√ß√£o</em> que descreve as informa√ß√µes <em>sobre o que aconteceu</em>. Isso permite que nosso efeito fique desacoplado do estado <code>step</code>. Nosso efeito n√£o se importa em <em>como</em> atualizamos o estado, apenas nos informa <em>sobre o que aconteceu</em>. O redutor centraliza a l√≥gica de atualiza√ß√£o:</p>\n<pre><code class=\"language-jsx{8,9}\">const initialState = {\n  count: 0,\n  step: 1,\n};\n\nfunction reducer(state, action) {\n  const { count, step } = state;\n  if (action.type === 'tick') {\n    return { count: count + step, step };\n  } else if (action.type === 'step') {\n    return { count, step: action.step };\n  } else {\n    throw new Error();\n  }\n}\n</code></pre>\n<p>(Aqui est√° <a href=\"https://codesandbox.io/s/xzr480k0np\">uma demonstra√ß√£o</a>, se voc√™ n√£o viu o link mais cedo).</p>\n<h2>Por que useReducer √© o \"Modo Trapa√ßa\" dos Hooks</h2>\n<p>N√≥s vimos como remover depend√™ncias quando um efeito precisa definir o estado com base no estado anterior ou em outra vari√°vel de estado. <strong>Mas e se precisarmos de ferramentas para calcular o pr√≥ximo estado?</strong> Por exemplo, talvez nossa API seja <code>&#x3C;Counter step={1} /></code>. Certamente n√£o podemos evitar especificar <code>props.step</code> como uma depend√™ncia, certo?</p>\n<p>Na verdade, n√≥s podemos! Podemos colocar o redutor em si dentro do nosso componente para ler <em>props</em>:</p>\n<pre><code class=\"language-jsx{1,6}\">function Counter({ step }) {\n  const [count, dispatch] = useReducer(reducer, 0);\n\n  function reducer(state, action) {\n    if (action.type === 'tick') {\n      return state + step;\n    } else {\n      throw new Error();\n    }\n  }\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      dispatch({ type: 'tick' });\n    }, 1000);\n    return () => clearInterval(id);\n  }, [dispatch]);\n\n  return &#x3C;h1>{count}&#x3C;/h1>;\n}\n</code></pre>\n<p>Esse padr√£o desativa algumas otimiza√ß√µes, ent√£o tente n√£o us√°-lo em todos os lugares, mas voc√™ pode acessar totalmente suas <em>props</em> em um redutor se precisar. (Aqui est√° <a href=\"https://codesandbox.io/s/7ypm405o8q\">uma demonstra√ß√£o</a>.)</p>\n<p><strong>Mesmo nesse caso, a identidade do <code>dispatch</code> ainda √© garantida como est√°vel entre as renderiza√ß√µes.</strong> Ent√£o voc√™ pode omiti-lo das deps de efeito, se quiser. Isso n√£o far√° com que o efeito seja executado novamente.</p>\n<p>Voc√™ pode estar se perguntando: como isso funciona? Como o redutor \"sabe\" as <em>props</em> chamadas de dentro de um efeito que pertence a outra renderiza√ß√£o? A resposta √© que, quando voc√™ usa <code>dispatch</code>, React lembra a a√ß√£o - mas ele ir√° chamar seu redutor durante a pr√≥xima renderiza√ß√£o. Nesse ponto, as <em>props</em> novas estar√£o no escopo e voc√™ n√£o estar√° dentro de um efeito.</p>\n<p><strong>√â por isso que eu gosto de pensar em <code>useReducer</code> como o \"Modo Trapa√ßa\" dos Hooks. Isso me permite desacoplar a l√≥gica de atualiza√ß√£o da descri√ß√£o do que aconteceu. Isso, por sua vez, me ajuda a remover depend√™ncias desnecess√°rias de meus efeitos e a evitar que sejam executados novamente com mais frequ√™ncia do que o necess√°rio.</strong></p>\n<h2>Movendo Fun√ß√µes Para Dentro Dos Efeitos</h2>\n<p>Um erro comum √© pensar que as fun√ß√µes n√£o devem ser depend√™ncias. Por exemplo, isso parece funcionar:</p>\n<pre><code class=\"language-jsx{13}\">function SearchResults() {\n  const [data, setData] = useState({ hits: [] });\n\n  async function fetchData() {\n    const result = await axios(\n      'https://hn.algolia.com/api/v1/search?query=react',\n    );\n    setData(result.data);\n  }\n\n  useEffect(() => {\n    fetchData();\n  }, []); // Isso t√° certo, n√©?\n\n  // ...\n</code></pre>\n<p><em>(<a href=\"https://codesandbox.io/s/8j4ykjyv0\">Este exemplo</a> √© adaptado de um √≥timo artigo do Robin Wieruch - <a href=\"https://www.robinwieruch.de/react-hooks-fetch-data/\">confira</a>!)</em></p>\n<p>E para ser claro, esse c√≥digo <em>funciona</em>. <strong>Mas o problema de simplesmente omitir fun√ß√µes locais √© que fica dif√≠cil saber se estamos lidando com todos os casos √† medida que o componente cresce!</strong></p>\n<p>Imagine que nosso c√≥digo foi dividido e cada fun√ß√£o era cinco vezes maior:</p>\n<pre><code class=\"language-jsx\">function SearchResults() {\n  // Imagine que essa fun√ß√£o √© longa\n  function getFetchUrl() {\n    return 'https://hn.algolia.com/api/v1/search?query=react';\n  }\n\n  // Imagine que essa fun√ß√£o tamb√©m √© longa\n  async function fetchData() {\n    const result = await axios(getFetchUrl());\n    setData(result.data);\n  }\n\n  useEffect(() => {\n    fetchData();\n  }, []);\n\n  // ...\n}\n</code></pre>\n<p>Agora vamos dizer que futuramente usamos algum estado ou <em>props</em> em uma dessas fun√ß√µes:</p>\n<pre><code class=\"language-jsx{6}\">function SearchResults() {\n  const [query, setQuery] = useState('react');\n\n  // Imagine que essa fun√ß√£o tamb√©m √© longa\n  function getFetchUrl() {\n    return 'https://hn.algolia.com/api/v1/search?query=' + query;\n  }\n\n  // Imagine que essa fun√ß√£o tamb√©m √© longa\n  async function fetchData() {\n    const result = await axios(getFetchUrl());\n    setData(result.data);\n  }\n\n  useEffect(() => {\n    fetchData();\n  }, []);\n\n  // ...\n}\n</code></pre>\n<p>Se nos esquecermos de atualizar as deps de qualquer um desses efeitos que chamam essas fun√ß√µes (possivelmente, atrav√©s de outras fun√ß√µes!), Nossos efeitos n√£o conseguir√£o sincronizar as mudan√ßas de nossas <em>props</em> e <em>state</em>. Isso n√£o soa ideal!</p>\n<p>Por sorte, existe uma solu√ß√£o f√°cil para esse problema. <strong>Se voc√™ usar apenas algumas fun√ß√µes <em>dentro</em> de um efeito, mova elas diretamente para <em>dentro</em> desse efeito:</strong></p>\n<pre><code class=\"language-jsx{4-12}\">function SearchResults() {\n  // ...\n  useEffect(() => {\n    // Movemos a fun√ß√£o para dentro do efeito!\n    function getFetchUrl() {\n      return 'https://hn.algolia.com/api/v1/search?query=react';\n    }\n\n    async function fetchData() {\n      const result = await axios(getFetchUrl());\n      setData(result.data);\n    }\n\n    fetchData();\n  }, []); // ‚úÖ As depend√™ncias est√£o corretas\n  // ...\n}\n</code></pre>\n<p>(<a href=\"https://codesandbox.io/s/04kp3jwwql\">Aqui est√° uma demonstra√ß√£o</a>.)</p>\n<p>Ent√£o, qual √© o benef√≠cio? N√£o precisamos mais pensar nas ‚Äúdepend√™ncias transitivas‚Äù. Nosso array de depend√™ncias n√£o est√° mais ocupado: <strong>realmente <em>n√£o</em> estamos usando nada do escopo externo do componente em nosso efeito.</strong></p>\n<p>Se mudarmos <code>getFetchUrl</code> para usar o estado <code>query</code>, teremos uma probabilidade maior de perceber que estamos editando isso <em>dentro</em> de um efeito - e, portanto, precisamos adicionar <code>query</code> √†s depend√™ncias do efeito:</p>\n<pre><code class=\"language-jsx{6,15}\">function SearchResults() {\n  const [query, setQuery] = useState('react');\n\n  useEffect(() => {\n    function getFetchUrl() {\n      return 'https://hn.algolia.com/api/v1/search?query=' + query;\n    }\n\n    async function fetchData() {\n      const result = await axios(getFetchUrl());\n      setData(result.data);\n    }\n\n    fetchData();\n  }, [query]); // ‚úÖ As depend√™ncias est√£o corretas\n\n  // ...\n}\n</code></pre>\n<p>(Aqui est√° <a href=\"https://codesandbox.io/s/pwm32zx7z7\">uma demonstra√ß√£o</a>.)</p>\n<p>Adicionando essa depend√™ncia, n√≥s n√£o estamos apenas \"apagizando o React\". Isso <em>faz sentido</em> para rebuscar os dados quando a consulta muda. <strong>O design de <code>useEffect</code> for√ßa voc√™ a notar que a mudan√ßa em nosso fluxo de dados e escolher como nossos efeitos devem sincronizar eles - ao inv√©s de ignor√°-los at√© que nosso usu√°rio final encontre um bug.</strong></p>\n<p>Gra√ßas a regra <code>exhaustive-deps</code> plugin <code>eslint-plugin-react-hooks</code>, <a href=\"https://github.com/facebook/react/issues/14920\">ele pode analisar os efeitos enquanto voc√™ digita no seu editor</a> e recebe sugest√µes sobre quais depend√™ncias est√£o faltando. Em outras palavras, uma m√°quina pode informar quais altera√ß√µes no fluxo de dados n√£o est√£o sendo tratadas corretamente por um componente:</p>\n<p><img src=\"./exhaustive-deps.gif\" alt=\"Gif da regra do linter\"></p>\n<p>Bem maneiro.</p>\n<h2>Mas Eu N√£o Posso Colocar Essa Fun√ß√£o Dentro De Um Efeito</h2>\n<p>√Äs vezes voc√™ pode n√£o vai querer mover uma fun√ß√£o para dentro de um efeito. Por exemplo, v√°rios efeitos no mesmo componente podem chamar a mesma fun√ß√£o e voc√™ n√£o quer copiar e colar sua l√≥gica. Ou talvez seja uma <em>prop</em>.</p>\n<p>Voc√™ deve evitar colocar uma fun√ß√£o como esta nas depend√™ncias do efeito? Eu acredito que n√£o. Novamente, os <strong>efeitos n√£o devem mentir sobre suas depend√™ncias.</strong> Geralmente existem solu√ß√µes melhores. Um equ√≠voco comum √© que \"uma fun√ß√£o nunca mudaria\". Mas, como aprendemos ao longo deste artigo, isso est√° longe de ser verdade. Na verdade, uma fun√ß√£o definida dentro de um componente muda em cada renderiza√ß√£o!</p>\n<p><strong>Isso por si s√≥ apresenta um problema.</strong> Vamos dizer que dois efeitos chama <code>getFetchUrl</code>:</p>\n<pre><code class=\"language-jsx\">function SearchResults() {\n  function getFetchUrl(query) {\n    return 'https://hn.algolia.com/api/v1/search?query=' + query;\n  }\n\n  useEffect(() => {\n    const url = getFetchUrl('react');\n    // ... Busca dados e faz algo ...\n  }, []); // üî¥ Depend√™ncia em falta: getFetchUrl\n\n  useEffect(() => {\n    const url = getFetchUrl('redux');\n    // ... Busca dados e faz algo ...\n  }, []); // üî¥ Depend√™ncia em falta: getFetchUrl\n\n  // ...\n}\n</code></pre>\n<p>Nesse caso, talvez voc√™ n√£o queira mover <code>getFetchUrl</code> para dentro de nenhum dos efeitos, pois n√£o seria capaz de compartilhar a l√≥gica.</p>\n<p>Por outro lado, se voc√™ for \"honesto\" sobre as depend√™ncias de efeitos, poder√° encontrar um problema. Como ambos os nossos efeitos dependem de <code>getFetchUrl</code> <strong>(o que √© diferente em cada renderiza√ß√£o)</strong>, nossos arrays de depend√™ncia s√£o in√∫teis:</p>\n<pre><code class=\"language-jsx{2-5}\">function SearchResults() {\n  // üî¥ Re-executa todos os efeitos em cada renderiza√ß√£o\n  function getFetchUrl(query) {\n    return 'https://hn.algolia.com/api/v1/search?query=' + query;\n  }\n\n  useEffect(() => {\n    const url = getFetchUrl('react');\n    // ... Busca dados e faz algo ...\n  }, [getFetchUrl]); // üöß As depend√™ncias est√£o corretas, mas elas mudam frequentemente\n\n  useEffect(() => {\n    const url = getFetchUrl('redux');\n    // ... Busca dados e faz algo ...\n  }, [getFetchUrl]); // üöß As depend√™ncias est√£o corretas, mas elas mudam frequentemente\n\n  // ...\n}\n</code></pre>\n<p>Uma solu√ß√£o tentadora para isso √© simplesmente evitar <code>getFetchUrl</code> na lista de depend√™ncias. No entanto, n√£o acho que seja uma boa solu√ß√£o. Isso torna dif√≠cil perceber quando <em>estamos</em> adicionando uma altera√ß√£o no fluxo de dados que <em>precisa</em> ser tratado por um efeito. Isso leva a erros como o \"intervalo que nunca atualiza\" que vimos anteriormente.</p>\n<p>Ao inv√©s disso, existem duas outras solu√ß√µes que s√£o mais simples.</p>\n<p><strong>Primeiro de tudo, se uma fun√ß√£o n√£o usa nada do escopo do componente, voc√™ pode mover ela para fora do componente e usa-l√° livremente dentro de seus efeitos:</strong></p>\n<pre><code class=\"language-jsx{1-4}\">// ‚úÖ N√£o √© afetado pelo fluxo de dados\nfunction getFetchUrl(query) {\n  return 'https://hn.algolia.com/api/v1/search?query=' + query;\n}\n\nfunction SearchResults() {\n  useEffect(() => {\n    const url = getFetchUrl('react');\n    // ... Busca dados e faz algo ...\n  }, []); // ‚úÖ As depend√™ncias est√£o corretas\n\n  useEffect(() => {\n    const url = getFetchUrl('redux');\n    // ... Busca dados e faz algo ...\n  }, []); // ‚úÖ As depend√™ncias est√£o corretas\n\n  // ...\n}\n</code></pre>\n<p>N√£o h√° necessidade de especific√°-las nas listas de deps porque a fun√ß√£o n√£o est√° no escopo de renderiza√ß√£o e n√£o pode ser afetada pelo fluxo de dados. Ela tamb√©m n√£o pode depender acidentalmente de <em>props</em> ou <em>state</em>.</p>\n<p>Como alternativa, voc√™ pode encapsular a fun√ß√£o no <a href=\"https://reactjs.org/docs/hooks-reference.html#usecallback\">Hook <code>useCallback</code></a>:</p>\n<pre><code class=\"language-jsx{2-5}\">function SearchResults() {\n  // ‚úÖ Preserva a identidade quando as *props* s√£o as mesmas\n  const getFetchUrl = useCallback((query) => {\n    return 'https://hn.algolia.com/api/v1/search?query=' + query;\n  }, []);  // ‚úÖ As depend√™ncias do Callback est√£o corretas\n\n  useEffect(() => {\n    const url = getFetchUrl('react');\n    // ... Busca dados e faz algo ...\n  }, [getFetchUrl]); // ‚úÖ As depend√™ncias do Efeito est√£o corretas\n\n  useEffect(() => {\n    const url = getFetchUrl('redux');\n    // ... Busca dados e faz algo ...\n  }, [getFetchUrl]); // ‚úÖ As depend√™ncias do Efeito est√£o corretas\n\n  // ...\n}\n</code></pre>\n<p><code>useCallback</code> √© como adicionar outra camada de verifica√ß√µes de depend√™ncia. Ele est√° resolvendo o problema do outro lado - <strong>ao inv√©s de evitar uma depend√™ncia de fun√ß√£o, n√≥s fazemos a fun√ß√£o em si s√≥ mudar quando necess√°rio.</strong></p>\n<p>Vamos ver porque esta abordagem √© √∫til. Anteriormente, nosso exemplo mostrava dois resultados de pesquisa (um para o termo 'react' e outro para 'redux'). Mas digamos que queremos adicionar uma entrada para que voc√™ possa procurar por uma <code>query</code> arbitr√°ria. Ent√£o, ao inv√©s de passarmos <code>query</code> como um argumento, <code>getFetchUrl</code> ir√° usar a vari√°vel do estado local.</p>\n<p>N√≥s veremos imediatamente que est√° faltando <code>query</code> na lista de depend√™ncia:</p>\n<pre><code class=\"language-jsx{5}\">function SearchResults() {\n  const [query, setQuery] = useState('react');\n  const getFetchUrl = useCallback(() => { // N√£o temos `query` como argumento\n    return 'https://hn.algolia.com/api/v1/search?query=' + query;\n  }, []); // üî¥ Est√° faltando uma depend√™ncia: `query`\n  // ...\n}\n</code></pre>\n<p>Se eu corrigir as depend√™ncias em <code>useCallback</code> e incluir <code>query</code>, qualquer efeito com <code>getFetchUrl</code> listado em suas \"deps\" ser√° executado novamente sempre que a <code>query</code> for alterada:</p>\n<pre><code class=\"language-jsx{4-7}\">function SearchResults() {\n  const [query, setQuery] = useState('react');\n\n  // ‚úÖ Preserva a identidade at√© a `query` mudar\n  const getFetchUrl = useCallback(() => {\n    return 'https://hn.algolia.com/api/v1/search?query=' + query;\n  }, [query]);  // ‚úÖ As depend√™ncias do Callback est√£o corretas\n\n  useEffect(() => {\n    const url = getFetchUrl();\n    // ... Busca dados e faz algo ...\n  }, [getFetchUrl]); // ‚úÖ As depend√™ncias do Efeito est√£o corretas\n\n  // ...\n}\n</code></pre>\n<p>Gra√ßas a <code>useCallback</code>, se <code>query</code> for a mesma, <code>getFetchUrl</code> tamb√©m permanece a mesma, e nosso efeito n√£o √© executado novamente. Mas se houver altera√ß√µes na <code>query</code> ent√£o <code>getFetchUrl</code> tamb√©m ir√° mudar e n√≥s buscaremos os dados novamente. √â muito parecido com quando voc√™ altera alguma c√©lula em uma planilha do Excel, e as outras c√©lulas que a usam recalculam automaticamente.</p>\n<p>Isso √© apenas uma conseq√º√™ncia de adotar o fluxo de dados e a mentalidade de sincroniza√ß√£o. <strong>A mesma solu√ß√£o funciona para objetos de fun√ß√£o passados pelos elementos pais:</strong></p>\n<pre><code class=\"language-jsx{4-8}\">function Parent() {\n  const [query, setQuery] = useState('react');\n\n  // ‚úÖ Preserva a identidade at√© a `query` mudar\n  const fetchData = useCallback(() => {\n    const url = 'https://hn.algolia.com/api/v1/search?query=' + query;\n    // ... Fetch data and return it ...\n  }, [query]);  // ‚úÖ As depend√™ncias do Callback est√£o corretas\n\n  return &#x3C;Child fetchData={fetchData} />\n}\n\nfunction Child({ fetchData }) {\n  let [data, setData] = useState(null);\n\n  useEffect(() => {\n    fetchData().then(setData);\n  }, [fetchData]); // ‚úÖ As depend√™ncias do Efeito est√£o corretas\n\n  // ...\n}\n</code></pre>\n<p>Como <code>fetchData</code> s√≥ muda quando o estado <code>query</code> do <code>Parent</code> muda, <code>Child</code> n√£o ir√° buscar dados at√© que seja realmente necess√°rio (houver alguma altera√ß√£o).</p>\n<h2>As Fun√ß√µes Fazem Parte do Fluxo de Dados?</h2>\n<p>Curiosamente, esse padr√£o quando quebrado com o paradigma de classes, realmente mostra a diferen√ßa entre efeitos e ciclos de vida. Considere esse exemplo:</p>\n<pre><code class=\"language-jsx{5-8,18-20}\">class Parent extends Component {\n  state = {\n    query: 'react'\n  };\n  fetchData = () => {\n    const url = 'https://hn.algolia.com/api/v1/search?query=' + this.state.query;\n    // ... Busca dados e faz algo ...\n  };\n  render() {\n    return &#x3C;Child fetchData={this.fetchData} />;\n  }\n}\n\nclass Child extends Component {\n  state = {\n    data: null\n  };\n  componentDidMount() {\n    this.props.fetchData();\n  }\n  render() {\n    // ...\n  }\n}\n</code></pre>\n<p>Voc√™ pode estar pensando: ‚ÄúVamos Dan, todos n√≥s sabemos que <code>useEffect</code> √© como <code>componentDidMount</code> e <code>componentDidUpdate</code> combinados, voc√™ n√£o pode continuar batendo naquele tambor!‚Äù <strong>No entanto, isso n√£o funciona nem com <code>componentDidUpdate</code>:</strong></p>\n<pre><code class=\"language-jsx{8-13}\">class Child extends Component {\n  state = {\n    data: null\n  };\n  componentDidMount() {\n    this.props.fetchData();\n  }\n  componentDidUpdate(prevProps) {\n    // üî¥ Essa condi√ß√£o nunca ser√° verdadeira\n    if (this.props.fetchData !== prevProps.fetchData) {\n      this.props.fetchData();\n    }\n  }\n  render() {\n    // ...\n  }\n}\n</code></pre>\n<p>Claro, <code>fetchData</code> √© um m√©todo de classe! (Ou melhor, uma propriedade de classe - mas isso n√£o muda nada.) N√£o ser√° diferente por causa de uma mudan√ßa de estado. Ent√£o, <code>this.props.fetchData</code> vai ser igual a <code>prevProps.fetchData</code> e n√≥s nunca vamos buscar dados novamente. Vamos apenas remover essa condi√ß√£o ent√£o?</p>\n<pre><code class=\"language-jsx\">  componentDidUpdate(prevProps) {\n    this.props.fetchData();\n  }\n</code></pre>\n<p>Oh, espere, isso busca dados em <em>cada</em> nova renderiza√ß√£o. (Se adicionarmos uma anima√ß√£o acima nessa √°rvore de componentes, √© uma maneira divertida de descobrir isso.) E se vincularmos com uma <code>query</code> espec√≠fica?</p>\n<pre><code class=\"language-jsx\">  render() {\n    return &#x3C;Child fetchData={this.fetchData.bind(this, this.state.query)} />;\n  }\n</code></pre>\n<p>Mas ent√£o <code>this.props.fetchData !== prevProps.fetchData</code> √© <em>sempre</em> verdadeiro, mesmo que <code>query</code> n√£o mude! Ent√£o, vamos <em>sempre</em> executar a busca de dados.</p>\n<p>A √∫nica solu√ß√£o real para esse enigma com as classes √© morder a l√≠ngua e passar a <code>query</code> em si para o componente <code>Child</code>. Na verdade, <code>Child</code>, acaba n√£o <em>usando</em> a <code>query</code>, mas pode disparar uma busca quando muda:</p>\n<pre><code class=\"language-jsx{10,22-24}\">class Parent extends Component {\n  state = {\n    query: 'react'\n  };\n  fetchData = () => {\n    const url = 'https://hn.algolia.com/api/v1/search?query=' + this.state.query;\n    // ... Busca dados e faz algo ...\n  };\n  render() {\n    return &#x3C;Child fetchData={this.fetchData} query={this.state.query} />;\n  }\n}\n\nclass Child extends Component {\n  state = {\n    data: null\n  };\n  componentDidMount() {\n    this.props.fetchData();\n  }\n  componentDidUpdate(prevProps) {\n    if (this.props.query !== prevProps.query) {\n      this.props.fetchData();\n    }\n  }\n  render() {\n    // ...\n  }\n}\n</code></pre>\n<p>Ao longo dos anos trabalhando com classes com o React, eu me acostumei em passar <em>props</em> desnecess√°rias e quebrar o encapsulamento de componentes pai, e eu s√≥ percebi o porque tivemos que fazer isso a uma semana atr√°s.</p>\n<p><strong>Com as classes, as fun√ß√µes em <em>props</em> por si s√≥ n√£o fazem parte do fluxo de dados.</strong> Os m√©todos se misturam a vari√°vel mut√°vel <code>this</code>, ent√£o n√£o podemos confiar em sua identidade para identificar qualquer coisa. Portanto, mesmo quando queremos apenas uma fun√ß√£o, temos que passar um monte de outros dados para poder \"diferenci√°-la\". N√£o podemos saber se o <code>this.props.fetchData</code> passado do pai depende de algum estado ou n√£o, e se esse estado acabou de mudar.</p>\n<p><strong>Com <code>useCallback</code>, fun√ß√µes podem participar totalmente no fluxo de dados.</strong> Podemos dizer que, se as entradas da fun√ß√£o forem alteradas, a fun√ß√£o em si mudou, mas se n√£o, ela permaneceu a mesma. Gra√ßas √† granularidade fornecida por <code>useCallback</code>, mudan√ßas nas <em>props</em> em <code>props.fetchData</code> podem se propagar automaticamente.</p>\n<p>Da mesma forma, <a href=\"https://reactjs.org/docs/hooks-reference.html#usememo\"><code>useMemo</code></a> nos permite fazer o mesmo para objetos complexos:</p>\n<pre><code class=\"language-jsx\">function ColorPicker() {\n  // N√£o quebra a compara√ß√£o raza no Child\n  // ao menos que `color` mude\n  const [color, setColor] = useState('pink');\n  const style = useMemo(() => ({ color }), [color]);\n  return &#x3C;Child style={style} />;\n}\n</code></pre>\n<p><strong>Eu quero enfatizar que colocar <code>useCallback</code> em todos os lugares n√£o √© ideal.</strong> √â uma √≥tima sa√≠da de emerg√™ncia e √© √∫til quando uma fun√ß√£o √© passada e chamada de dentro de um efeito em elementos filhos. Ou se voc√™ est√° tentando impedir a quebra de memoiza√ß√£o de um componente filho. Mas Hooks fazem <a href=\"https://reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down\">um melhor servi√ßo para evitar passar callbacks completamente</a></p>\n<p>Nos exemplos acima, eu gostaria que <code>fetchData</code> estivesse dentro do meu efeito (que por sua vez poderia ser extra√≠do para um Hook personalizado) ou uma importa√ß√£o de n√≠vel superior. Eu quero manter os efeitos simples, e utilizar retornos de chamadas neles n√£o ajudam. (\"E se alguma <code>props.onComplete</code> for alterada enquando uma busca de dados estiver em andamento?\") Voc√™ pode <a href=\"https://overreacted.io/a-complete-guide-to-useeffect/#swimming-against-the-tide\">simular o comportamento da classe</a>, mas isso n√£o resolve essa <strong>condi√ß√£o de corrida</strong> (<em>race conditions</em>).</p>\n<h2>Falando em Condi√ß√µes de Corrida</h2>\n<p>Um exemplo cl√°ssico de busca de dados com classes pode ser feito assim:</p>\n<pre><code class=\"language-jsx\">class Article extends Component {\n  state = {\n    article: null\n  };\n  componentDidMount() {\n    this.fetchData(this.props.id);\n  }\n  async fetchData(id) {\n    const article = await API.fetchArticle(id);\n    this.setState({ article });\n  }\n  // ...\n}\n</code></pre>\n<p>Como voc√™ provavelmente sabe, esse c√≥digo √© <em>buggy</em>. Tamb√©m n√£o suporta atualiza√ß√µes. Ent√£o, o segundo exemplo cl√°ssico que voc√™ pode encontrar online √© algo assim:</p>\n<pre><code class=\"language-jsx{8-12}\">class Article extends Component {\n  state = {\n    article: null\n  };\n  componentDidMount() {\n    this.fetchData(this.props.id);\n  }\n  componentDidUpdate(prevProps) {\n    if (prevProps.id !== this.props.id) {\n      this.fetchData(this.props.id);\n    }\n  }\n  async fetchData(id) {\n    const article = await API.fetchArticle(id);\n    this.setState({ article });\n  }\n  // ...\n}\n</code></pre>\n<p>Isso definitivamente √© melhor! Mas ainda √© <em>buggy</em>. A raz√£o pela qual √© <em>buggy</em> √© que o pedido pode sair de ordem. Se eu estou buscando <code>{id: 10}</code>, e mudo para <code>{id: 20}</code>, mas a solicita√ß√£o <code>{id: 20}</code> chegou primeiro lugar, a solicita√ß√£o que come√ßou mais cedo, e terminou depois, incorretamente substituiria meu estado.</p>\n<p>Isso √© chamado de <strong>condi√ß√£o de corrida</strong>, e √© t√≠pico no c√≥digo que mistura <code>async</code>/<code>await</code> (que sup√µe que algo espera pelo resultado) com fluxo de dados de cima-baixo (<em>props</em> ou <em>state</em> podem mudar enquanto estamos no meio de uma fun√ß√£o ass√≠ncrona).</p>\n<p>Os efeitos n√£o resolvem este problema magicamente, embora avisem se voc√™ tentar passar uma fun√ß√£o <code>async</code> diretamente para o efeito. (Precisamos melhorar esse aviso para explicar melhor os problemas que voc√™ pode encontrar.)</p>\n<p>Se a abordagem ass√≠ncrona que voc√™ usa suportar cancelamento, isso √© √≥timo! Voc√™ pode cancelar a solicita√ß√£o ass√≠ncrona diretamente na sua fun√ß√£o de limpeza.</p>\n<p>Alternativamente, a abordagem tempor√°ria mais f√°cil √© rastre√°-la com um booleano:</p>\n<pre><code class=\"language-jsx{5,9,16-18}\">function Article({ id }) {\n  const [article, setArticle] = useState(null);\n\n  useEffect(() => {\n    let didCancel = false;\n\n    async function fetchData() {\n      const article = await API.fetchArticle(id);\n      if (!didCancel) {\n        setArticle(article);\n      }\n    }\n\n    fetchData();\n\n    return () => {\n      didCancel = true;\n    };\n  }, [id]);\n\n  // ...\n}\n</code></pre>\n<p><a href=\"https://www.robinwieruch.de/react-hooks-fetch-data/\">Este artigo</a> detalha como voc√™ pode manipular erros e estados de carregamento, al√©m de extrair essa l√≥gica em um Hook personalizado. Eu recomendo a leitura caso voc√™ queira saber mais sobre como buscar dados com Hooks.</p>\n<h2>Elevando o N√≠vel</h2>\n<p>Com a mentalidade de ciclo de vida das classes, os efeitos colaterais se comportam de maneira diferente do que √© renderizado. A renderiza√ß√£o de uma interface do usu√°rio √© guiada por <em>props</em> e <em>state</em>, e √© garantido que seja consistente com eles, mas os efeitos colaterais n√£o s√£o. Esta √© uma fonte comum de erros.</p>\n<p>Com a mentalidade de <code>useEffect</code>, as coisas s√£o sincronizadas por padr√£o. Os efeitos colaterais tornam-se parte do fluxo de dados do React. Para cada chamada <code>useEffect</code>, uma vez que voc√™ o fa√ßa corretamente, o seu componente cuida de casos extremos muito melhor.</p>\n<p>No entanto, o custo inicial de acertar √© maior. Isso pode ser chato. Escrever um c√≥digo de sincroniza√ß√£o que lide bem com os casos extremos √© inerentemente mais dif√≠cil do que disparar efeitos colaterais √∫nicos que n√£o s√£o consistentes com a renderiza√ß√£o.</p>\n<p>Isso poderia ser preocupante se <code>useEffect</code> fosse <em>a</em> ferramenta que voc√™ usa a maior parte do tempo. No entanto, √© um bloco de constru√ß√£o de baixo n√≠vel. Estamos no in√≠cio dos Hooks, ent√£o todo mundo usa blocos de baixo n√≠vel o tempo todo, especialmente em tutoriais. Mas, na pr√°tica, √© prov√°vel que a comunidade comece a migrar para abstra√ß√µes em torno dos Hooks, pois boas APIs ganham impulso.</p>\n<p>Estou vendo aplicativos diferentes criarem seus pr√≥prios Hooks, como <code>useFetch</code>, que encapsula parte da l√≥gica de autentica√ß√£o do aplicativo ou <code>useTheme</code>, que usa o contexto para injetar um tema. Uma vez que voc√™ tenha uma caixa de ferramentas dessas, voc√™ n√£o usar√° o <code>useEffect</code> <em>t√£o</em> frequentemente. Mas a resili√™ncia que ele traz, cria benef√≠cios para Hooks constru√≠do por cima dele.</p>\n<p>At√© agora, <code>useEffect</code> √© mais usado para busca de dados. Mas a busca de dados n√£o √© exatamente um problema de sincroniza√ß√£o. Isto √© especialmente √≥bvio porque as nossas depend√™ncias s√£o frequentemente <code>[]</code>. Ent√£o, o que estamos sincronizando?</p>\n<p>A longo prazo, <a href=\"https://reactjs.org/blog/2018/11/27/react-16-roadmap.html#react-16x-mid-2019-the-one-with-suspense-for-data-fetching\">Suspense para Busca de Dados</a> permitir√° que bibliotecas de terceiros tenham uma maneira, de primeira classe, de instruir o React a suspender a renderiza√ß√£o at√© que algo ass√≠ncrono (qualquer coisa: c√≥digo, dados, imagens) estejam prontos.</p>\n<p>Como o Suspense cobre gradualmente mais casos de busca de dados, eu antecipo que <code>useEffect</code> vai ficar no plano de fundo, como uma ferramenta avan√ßada para casos em que voc√™ realmente deseja sincronizar <em>props</em> e <em>state</em> para algum efeito colateral. Ao contr√°rio da busca de dados, ele lida com este caso naturalmente, pois ele foi projetado para isso. Mas at√© l√°, Hooks personalizados como <a href=\"https://www.robinwieruch.de/react-hooks-fetch-data/\">mostrado aqui</a>, s√£o uma boa maneira de reutilizar a l√≥gica de busca de dados.</p>\n<h2>Finalizando</h2>\n<p>Agora que voc√™ sabe tudo o que eu sei sobre o uso de efeitos, confira o <a href=\"#tldr\">TLDR</a> no in√≠cio. Ele faz sentido? Perdi alguma coisa? (Eu ainda tenho mais papel aqui!)</p>\n<p>Eu adoraria ouvir de voc√™ no Twitter! Obrigado pela leitura.</p>","timeToRead":50,"frontmatter":{"title":"Um guia completo para useEffect","date":"March 09, 2019","spoiler":"Efeitos fazem parte do seu fluxo de dados.","cta":null},"fields":{"slug":"/pt-br/a-complete-guide-to-useeffect/","langKey":"pt-br"}}},"pageContext":{"slug":"/pt-br/a-complete-guide-to-useeffect/","translations":["zh-hans","zh-hant","pt-br","ja","ko"],"translatedLinks":[]}},"staticQueryHashes":["336482444"]}